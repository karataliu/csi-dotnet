// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: csi.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Csi.V0 {

  /// <summary>Holder for reflection information generated from csi.proto</summary>
  public static partial class CsiReflection {

    #region Descriptor
    /// <summary>File descriptor for csi.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static CsiReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "Cgljc2kucHJvdG8SBmNzaS52MCIWChRHZXRQbHVnaW5JbmZvUmVxdWVzdCKt",
            "AQoVR2V0UGx1Z2luSW5mb1Jlc3BvbnNlEgwKBG5hbWUYASABKAkSFgoOdmVu",
            "ZG9yX3ZlcnNpb24YAiABKAkSPQoIbWFuaWZlc3QYAyADKAsyKy5jc2kudjAu",
            "R2V0UGx1Z2luSW5mb1Jlc3BvbnNlLk1hbmlmZXN0RW50cnkaLwoNTWFuaWZl",
            "c3RFbnRyeRILCgNrZXkYASABKAkSDQoFdmFsdWUYAiABKAk6AjgBIh4KHEdl",
            "dFBsdWdpbkNhcGFiaWxpdGllc1JlcXVlc3QiTwodR2V0UGx1Z2luQ2FwYWJp",
            "bGl0aWVzUmVzcG9uc2USLgoMY2FwYWJpbGl0aWVzGAIgAygLMhguY3NpLnYw",
            "LlBsdWdpbkNhcGFiaWxpdHkivAEKEFBsdWdpbkNhcGFiaWxpdHkSMwoHc2Vy",
            "dmljZRgBIAEoCzIgLmNzaS52MC5QbHVnaW5DYXBhYmlsaXR5LlNlcnZpY2VI",
            "ABprCgdTZXJ2aWNlEjMKBHR5cGUYASABKA4yJS5jc2kudjAuUGx1Z2luQ2Fw",
            "YWJpbGl0eS5TZXJ2aWNlLlR5cGUiKwoEVHlwZRILCgdVTktOT1dOEAASFgoS",
            "Q09OVFJPTExFUl9TRVJWSUNFEAFCBgoEdHlwZSIOCgxQcm9iZVJlcXVlc3Qi",
            "DwoNUHJvYmVSZXNwb25zZSKaAwoTQ3JlYXRlVm9sdW1lUmVxdWVzdBIMCgRu",
            "YW1lGAEgASgJEi0KDmNhcGFjaXR5X3JhbmdlGAIgASgLMhUuY3NpLnYwLkNh",
            "cGFjaXR5UmFuZ2USNQoTdm9sdW1lX2NhcGFiaWxpdGllcxgDIAMoCzIYLmNz",
            "aS52MC5Wb2x1bWVDYXBhYmlsaXR5Ej8KCnBhcmFtZXRlcnMYBCADKAsyKy5j",
            "c2kudjAuQ3JlYXRlVm9sdW1lUmVxdWVzdC5QYXJhbWV0ZXJzRW50cnkSWwoZ",
            "Y29udHJvbGxlcl9jcmVhdGVfc2VjcmV0cxgFIAMoCzI4LmNzaS52MC5DcmVh",
            "dGVWb2x1bWVSZXF1ZXN0LkNvbnRyb2xsZXJDcmVhdGVTZWNyZXRzRW50cnka",
            "MQoPUGFyYW1ldGVyc0VudHJ5EgsKA2tleRgBIAEoCRINCgV2YWx1ZRgCIAEo",
            "CToCOAEaPgocQ29udHJvbGxlckNyZWF0ZVNlY3JldHNFbnRyeRILCgNrZXkY",
            "ASABKAkSDQoFdmFsdWUYAiABKAk6AjgBIjYKFENyZWF0ZVZvbHVtZVJlc3Bv",
            "bnNlEh4KBnZvbHVtZRgBIAEoCzIOLmNzaS52MC5Wb2x1bWUi9gMKEFZvbHVt",
            "ZUNhcGFiaWxpdHkSNQoFYmxvY2sYASABKAsyJC5jc2kudjAuVm9sdW1lQ2Fw",
            "YWJpbGl0eS5CbG9ja1ZvbHVtZUgAEjUKBW1vdW50GAIgASgLMiQuY3NpLnYw",
            "LlZvbHVtZUNhcGFiaWxpdHkuTW91bnRWb2x1bWVIABI4CgthY2Nlc3NfbW9k",
            "ZRgDIAEoCzIjLmNzaS52MC5Wb2x1bWVDYXBhYmlsaXR5LkFjY2Vzc01vZGUa",
            "DQoLQmxvY2tWb2x1bWUaMwoLTW91bnRWb2x1bWUSDwoHZnNfdHlwZRgBIAEo",
            "CRITCgttb3VudF9mbGFncxgCIAMoCRrmAQoKQWNjZXNzTW9kZRI2CgRtb2Rl",
            "GAEgASgOMiguY3NpLnYwLlZvbHVtZUNhcGFiaWxpdHkuQWNjZXNzTW9kZS5N",
            "b2RlIp8BCgRNb2RlEgsKB1VOS05PV04QABIWChJTSU5HTEVfTk9ERV9XUklU",
            "RVIQARIbChdTSU5HTEVfTk9ERV9SRUFERVJfT05MWRACEhoKFk1VTFRJX05P",
            "REVfUkVBREVSX09OTFkQAxIcChhNVUxUSV9OT0RFX1NJTkdMRV9XUklURVIQ",
            "BBIbChdNVUxUSV9OT0RFX01VTFRJX1dSSVRFUhAFQg0KC2FjY2Vzc190eXBl",
            "IjwKDUNhcGFjaXR5UmFuZ2USFgoOcmVxdWlyZWRfYnl0ZXMYASABKAMSEwoL",
            "bGltaXRfYnl0ZXMYAiABKAMikwEKBlZvbHVtZRIWCg5jYXBhY2l0eV9ieXRl",
            "cxgBIAEoAxIKCgJpZBgCIAEoCRIyCgphdHRyaWJ1dGVzGAMgAygLMh4uY3Np",
            "LnYwLlZvbHVtZS5BdHRyaWJ1dGVzRW50cnkaMQoPQXR0cmlidXRlc0VudHJ5",
            "EgsKA2tleRgBIAEoCRINCgV2YWx1ZRgCIAEoCToCOAEixQEKE0RlbGV0ZVZv",
            "bHVtZVJlcXVlc3QSEQoJdm9sdW1lX2lkGAEgASgJElsKGWNvbnRyb2xsZXJf",
            "ZGVsZXRlX3NlY3JldHMYAiADKAsyOC5jc2kudjAuRGVsZXRlVm9sdW1lUmVx",
            "dWVzdC5Db250cm9sbGVyRGVsZXRlU2VjcmV0c0VudHJ5Gj4KHENvbnRyb2xs",
            "ZXJEZWxldGVTZWNyZXRzRW50cnkSCwoDa2V5GAEgASgJEg0KBXZhbHVlGAIg",
            "ASgJOgI4ASIWChREZWxldGVWb2x1bWVSZXNwb25zZSLIAwoeQ29udHJvbGxl",
            "clB1Ymxpc2hWb2x1bWVSZXF1ZXN0EhEKCXZvbHVtZV9pZBgBIAEoCRIPCgdu",
            "b2RlX2lkGAIgASgJEjMKEXZvbHVtZV9jYXBhYmlsaXR5GAMgASgLMhguY3Np",
            "LnYwLlZvbHVtZUNhcGFiaWxpdHkSEAoIcmVhZG9ubHkYBCABKAgSaAoaY29u",
            "dHJvbGxlcl9wdWJsaXNoX3NlY3JldHMYBSADKAsyRC5jc2kudjAuQ29udHJv",
            "bGxlclB1Ymxpc2hWb2x1bWVSZXF1ZXN0LkNvbnRyb2xsZXJQdWJsaXNoU2Vj",
            "cmV0c0VudHJ5ElcKEXZvbHVtZV9hdHRyaWJ1dGVzGAYgAygLMjwuY3NpLnYw",
            "LkNvbnRyb2xsZXJQdWJsaXNoVm9sdW1lUmVxdWVzdC5Wb2x1bWVBdHRyaWJ1",
            "dGVzRW50cnkaPwodQ29udHJvbGxlclB1Ymxpc2hTZWNyZXRzRW50cnkSCwoD",
            "a2V5GAEgASgJEg0KBXZhbHVlGAIgASgJOgI4ARo3ChVWb2x1bWVBdHRyaWJ1",
            "dGVzRW50cnkSCwoDa2V5GAEgASgJEg0KBXZhbHVlGAIgASgJOgI4ASKlAQof",
            "Q29udHJvbGxlclB1Ymxpc2hWb2x1bWVSZXNwb25zZRJOCgxwdWJsaXNoX2lu",
            "Zm8YASADKAsyOC5jc2kudjAuQ29udHJvbGxlclB1Ymxpc2hWb2x1bWVSZXNw",
            "b25zZS5QdWJsaXNoSW5mb0VudHJ5GjIKEFB1Ymxpc2hJbmZvRW50cnkSCwoD",
            "a2V5GAEgASgJEg0KBXZhbHVlGAIgASgJOgI4ASL5AQogQ29udHJvbGxlclVu",
            "cHVibGlzaFZvbHVtZVJlcXVlc3QSEQoJdm9sdW1lX2lkGAEgASgJEg8KB25v",
            "ZGVfaWQYAiABKAkSbgocY29udHJvbGxlcl91bnB1Ymxpc2hfc2VjcmV0cxgD",
            "IAMoCzJILmNzaS52MC5Db250cm9sbGVyVW5wdWJsaXNoVm9sdW1lUmVxdWVz",
            "dC5Db250cm9sbGVyVW5wdWJsaXNoU2VjcmV0c0VudHJ5GkEKH0NvbnRyb2xs",
            "ZXJVbnB1Ymxpc2hTZWNyZXRzRW50cnkSCwoDa2V5GAEgASgJEg0KBXZhbHVl",
            "GAIgASgJOgI4ASIjCiFDb250cm9sbGVyVW5wdWJsaXNoVm9sdW1lUmVzcG9u",
            "c2UiggIKIVZhbGlkYXRlVm9sdW1lQ2FwYWJpbGl0aWVzUmVxdWVzdBIRCgl2",
            "b2x1bWVfaWQYASABKAkSNQoTdm9sdW1lX2NhcGFiaWxpdGllcxgCIAMoCzIY",
            "LmNzaS52MC5Wb2x1bWVDYXBhYmlsaXR5EloKEXZvbHVtZV9hdHRyaWJ1dGVz",
            "GAMgAygLMj8uY3NpLnYwLlZhbGlkYXRlVm9sdW1lQ2FwYWJpbGl0aWVzUmVx",
            "dWVzdC5Wb2x1bWVBdHRyaWJ1dGVzRW50cnkaNwoVVm9sdW1lQXR0cmlidXRl",
            "c0VudHJ5EgsKA2tleRgBIAEoCRINCgV2YWx1ZRgCIAEoCToCOAEiSAoiVmFs",
            "aWRhdGVWb2x1bWVDYXBhYmlsaXRpZXNSZXNwb25zZRIRCglzdXBwb3J0ZWQY",
            "ASABKAgSDwoHbWVzc2FnZRgCIAEoCSJBChJMaXN0Vm9sdW1lc1JlcXVlc3QS",
            "EwoLbWF4X2VudHJpZXMYASABKAUSFgoOc3RhcnRpbmdfdG9rZW4YAiABKAki",
            "hgEKE0xpc3RWb2x1bWVzUmVzcG9uc2USMgoHZW50cmllcxgBIAMoCzIhLmNz",
            "aS52MC5MaXN0Vm9sdW1lc1Jlc3BvbnNlLkVudHJ5EhIKCm5leHRfdG9rZW4Y",
            "AiABKAkaJwoFRW50cnkSHgoGdm9sdW1lGAEgASgLMg4uY3NpLnYwLlZvbHVt",
            "ZSK+AQoSR2V0Q2FwYWNpdHlSZXF1ZXN0EjUKE3ZvbHVtZV9jYXBhYmlsaXRp",
            "ZXMYASADKAsyGC5jc2kudjAuVm9sdW1lQ2FwYWJpbGl0eRI+CgpwYXJhbWV0",
            "ZXJzGAIgAygLMiouY3NpLnYwLkdldENhcGFjaXR5UmVxdWVzdC5QYXJhbWV0",
            "ZXJzRW50cnkaMQoPUGFyYW1ldGVyc0VudHJ5EgsKA2tleRgBIAEoCRINCgV2",
            "YWx1ZRgCIAEoCToCOAEiMQoTR2V0Q2FwYWNpdHlSZXNwb25zZRIaChJhdmFp",
            "bGFibGVfY2FwYWNpdHkYASABKAMiIgogQ29udHJvbGxlckdldENhcGFiaWxp",
            "dGllc1JlcXVlc3QiXgohQ29udHJvbGxlckdldENhcGFiaWxpdGllc1Jlc3Bv",
            "bnNlEjkKDGNhcGFiaWxpdGllcxgCIAMoCzIjLmNzaS52MC5Db250cm9sbGVy",
            "U2VydmljZUNhcGFiaWxpdHkikgIKG0NvbnRyb2xsZXJTZXJ2aWNlQ2FwYWJp",
            "bGl0eRI2CgNycGMYASABKAsyJy5jc2kudjAuQ29udHJvbGxlclNlcnZpY2VD",
            "YXBhYmlsaXR5LlJQQ0gAGrIBCgNSUEMSOgoEdHlwZRgBIAEoDjIsLmNzaS52",
            "MC5Db250cm9sbGVyU2VydmljZUNhcGFiaWxpdHkuUlBDLlR5cGUibwoEVHlw",
            "ZRILCgdVTktOT1dOEAASGAoUQ1JFQVRFX0RFTEVURV9WT0xVTUUQARIcChhQ",
            "VUJMSVNIX1VOUFVCTElTSF9WT0xVTUUQAhIQCgxMSVNUX1ZPTFVNRVMQAxIQ",
            "CgxHRVRfQ0FQQUNJVFkQBEIGCgR0eXBlIo0EChZOb2RlU3RhZ2VWb2x1bWVS",
            "ZXF1ZXN0EhEKCXZvbHVtZV9pZBgBIAEoCRJFCgxwdWJsaXNoX2luZm8YAiAD",
            "KAsyLy5jc2kudjAuTm9kZVN0YWdlVm9sdW1lUmVxdWVzdC5QdWJsaXNoSW5m",
            "b0VudHJ5EhsKE3N0YWdpbmdfdGFyZ2V0X3BhdGgYAyABKAkSMwoRdm9sdW1l",
            "X2NhcGFiaWxpdHkYBCABKAsyGC5jc2kudjAuVm9sdW1lQ2FwYWJpbGl0eRJQ",
            "ChJub2RlX3N0YWdlX3NlY3JldHMYBSADKAsyNC5jc2kudjAuTm9kZVN0YWdl",
            "Vm9sdW1lUmVxdWVzdC5Ob2RlU3RhZ2VTZWNyZXRzRW50cnkSTwoRdm9sdW1l",
            "X2F0dHJpYnV0ZXMYBiADKAsyNC5jc2kudjAuTm9kZVN0YWdlVm9sdW1lUmVx",
            "dWVzdC5Wb2x1bWVBdHRyaWJ1dGVzRW50cnkaMgoQUHVibGlzaEluZm9FbnRy",
            "eRILCgNrZXkYASABKAkSDQoFdmFsdWUYAiABKAk6AjgBGjcKFU5vZGVTdGFn",
            "ZVNlY3JldHNFbnRyeRILCgNrZXkYASABKAkSDQoFdmFsdWUYAiABKAk6AjgB",
            "GjcKFVZvbHVtZUF0dHJpYnV0ZXNFbnRyeRILCgNrZXkYASABKAkSDQoFdmFs",
            "dWUYAiABKAk6AjgBIhkKF05vZGVTdGFnZVZvbHVtZVJlc3BvbnNlIkoKGE5v",
            "ZGVVbnN0YWdlVm9sdW1lUmVxdWVzdBIRCgl2b2x1bWVfaWQYASABKAkSGwoT",
            "c3RhZ2luZ190YXJnZXRfcGF0aBgCIAEoCSIbChlOb2RlVW5zdGFnZVZvbHVt",
            "ZVJlc3BvbnNlIsIEChhOb2RlUHVibGlzaFZvbHVtZVJlcXVlc3QSEQoJdm9s",
            "dW1lX2lkGAEgASgJEkcKDHB1Ymxpc2hfaW5mbxgCIAMoCzIxLmNzaS52MC5O",
            "b2RlUHVibGlzaFZvbHVtZVJlcXVlc3QuUHVibGlzaEluZm9FbnRyeRIbChNz",
            "dGFnaW5nX3RhcmdldF9wYXRoGAMgASgJEhMKC3RhcmdldF9wYXRoGAQgASgJ",
            "EjMKEXZvbHVtZV9jYXBhYmlsaXR5GAUgASgLMhguY3NpLnYwLlZvbHVtZUNh",
            "cGFiaWxpdHkSEAoIcmVhZG9ubHkYBiABKAgSVgoUbm9kZV9wdWJsaXNoX3Nl",
            "Y3JldHMYByADKAsyOC5jc2kudjAuTm9kZVB1Ymxpc2hWb2x1bWVSZXF1ZXN0",
            "Lk5vZGVQdWJsaXNoU2VjcmV0c0VudHJ5ElEKEXZvbHVtZV9hdHRyaWJ1dGVz",
            "GAggAygLMjYuY3NpLnYwLk5vZGVQdWJsaXNoVm9sdW1lUmVxdWVzdC5Wb2x1",
            "bWVBdHRyaWJ1dGVzRW50cnkaMgoQUHVibGlzaEluZm9FbnRyeRILCgNrZXkY",
            "ASABKAkSDQoFdmFsdWUYAiABKAk6AjgBGjkKF05vZGVQdWJsaXNoU2VjcmV0",
            "c0VudHJ5EgsKA2tleRgBIAEoCRINCgV2YWx1ZRgCIAEoCToCOAEaNwoVVm9s",
            "dW1lQXR0cmlidXRlc0VudHJ5EgsKA2tleRgBIAEoCRINCgV2YWx1ZRgCIAEo",
            "CToCOAEiGwoZTm9kZVB1Ymxpc2hWb2x1bWVSZXNwb25zZSJEChpOb2RlVW5w",
            "dWJsaXNoVm9sdW1lUmVxdWVzdBIRCgl2b2x1bWVfaWQYASABKAkSEwoLdGFy",
            "Z2V0X3BhdGgYAiABKAkiHQobTm9kZVVucHVibGlzaFZvbHVtZVJlc3BvbnNl",
            "IhIKEE5vZGVHZXRJZFJlcXVlc3QiJAoRTm9kZUdldElkUmVzcG9uc2USDwoH",
            "bm9kZV9pZBgBIAEoCSIcChpOb2RlR2V0Q2FwYWJpbGl0aWVzUmVxdWVzdCJS",
            "ChtOb2RlR2V0Q2FwYWJpbGl0aWVzUmVzcG9uc2USMwoMY2FwYWJpbGl0aWVz",
            "GAEgAygLMh0uY3NpLnYwLk5vZGVTZXJ2aWNlQ2FwYWJpbGl0eSK9AQoVTm9k",
            "ZVNlcnZpY2VDYXBhYmlsaXR5EjAKA3JwYxgBIAEoCzIhLmNzaS52MC5Ob2Rl",
            "U2VydmljZUNhcGFiaWxpdHkuUlBDSAAaagoDUlBDEjQKBHR5cGUYASABKA4y",
            "Ji5jc2kudjAuTm9kZVNlcnZpY2VDYXBhYmlsaXR5LlJQQy5UeXBlIi0KBFR5",
            "cGUSCwoHVU5LTk9XThAAEhgKFFNUQUdFX1VOU1RBR0VfVk9MVU1FEAFCBgoE",
            "dHlwZTL6AQoISWRlbnRpdHkSTgoNR2V0UGx1Z2luSW5mbxIcLmNzaS52MC5H",
            "ZXRQbHVnaW5JbmZvUmVxdWVzdBodLmNzaS52MC5HZXRQbHVnaW5JbmZvUmVz",
            "cG9uc2UiABJmChVHZXRQbHVnaW5DYXBhYmlsaXRpZXMSJC5jc2kudjAuR2V0",
            "UGx1Z2luQ2FwYWJpbGl0aWVzUmVxdWVzdBolLmNzaS52MC5HZXRQbHVnaW5D",
            "YXBhYmlsaXRpZXNSZXNwb25zZSIAEjYKBVByb2JlEhQuY3NpLnYwLlByb2Jl",
            "UmVxdWVzdBoVLmNzaS52MC5Qcm9iZVJlc3BvbnNlIgAyhwYKCkNvbnRyb2xs",
            "ZXISSwoMQ3JlYXRlVm9sdW1lEhsuY3NpLnYwLkNyZWF0ZVZvbHVtZVJlcXVl",
            "c3QaHC5jc2kudjAuQ3JlYXRlVm9sdW1lUmVzcG9uc2UiABJLCgxEZWxldGVW",
            "b2x1bWUSGy5jc2kudjAuRGVsZXRlVm9sdW1lUmVxdWVzdBocLmNzaS52MC5E",
            "ZWxldGVWb2x1bWVSZXNwb25zZSIAEmwKF0NvbnRyb2xsZXJQdWJsaXNoVm9s",
            "dW1lEiYuY3NpLnYwLkNvbnRyb2xsZXJQdWJsaXNoVm9sdW1lUmVxdWVzdBon",
            "LmNzaS52MC5Db250cm9sbGVyUHVibGlzaFZvbHVtZVJlc3BvbnNlIgAScgoZ",
            "Q29udHJvbGxlclVucHVibGlzaFZvbHVtZRIoLmNzaS52MC5Db250cm9sbGVy",
            "VW5wdWJsaXNoVm9sdW1lUmVxdWVzdBopLmNzaS52MC5Db250cm9sbGVyVW5w",
            "dWJsaXNoVm9sdW1lUmVzcG9uc2UiABJ1ChpWYWxpZGF0ZVZvbHVtZUNhcGFi",
            "aWxpdGllcxIpLmNzaS52MC5WYWxpZGF0ZVZvbHVtZUNhcGFiaWxpdGllc1Jl",
            "cXVlc3QaKi5jc2kudjAuVmFsaWRhdGVWb2x1bWVDYXBhYmlsaXRpZXNSZXNw",
            "b25zZSIAEkgKC0xpc3RWb2x1bWVzEhouY3NpLnYwLkxpc3RWb2x1bWVzUmVx",
            "dWVzdBobLmNzaS52MC5MaXN0Vm9sdW1lc1Jlc3BvbnNlIgASSAoLR2V0Q2Fw",
            "YWNpdHkSGi5jc2kudjAuR2V0Q2FwYWNpdHlSZXF1ZXN0GhsuY3NpLnYwLkdl",
            "dENhcGFjaXR5UmVzcG9uc2UiABJyChlDb250cm9sbGVyR2V0Q2FwYWJpbGl0",
            "aWVzEiguY3NpLnYwLkNvbnRyb2xsZXJHZXRDYXBhYmlsaXRpZXNSZXF1ZXN0",
            "GikuY3NpLnYwLkNvbnRyb2xsZXJHZXRDYXBhYmlsaXRpZXNSZXNwb25zZSIA",
            "MpwECgROb2RlElQKD05vZGVTdGFnZVZvbHVtZRIeLmNzaS52MC5Ob2RlU3Rh",
            "Z2VWb2x1bWVSZXF1ZXN0Gh8uY3NpLnYwLk5vZGVTdGFnZVZvbHVtZVJlc3Bv",
            "bnNlIgASWgoRTm9kZVVuc3RhZ2VWb2x1bWUSIC5jc2kudjAuTm9kZVVuc3Rh",
            "Z2VWb2x1bWVSZXF1ZXN0GiEuY3NpLnYwLk5vZGVVbnN0YWdlVm9sdW1lUmVz",
            "cG9uc2UiABJaChFOb2RlUHVibGlzaFZvbHVtZRIgLmNzaS52MC5Ob2RlUHVi",
            "bGlzaFZvbHVtZVJlcXVlc3QaIS5jc2kudjAuTm9kZVB1Ymxpc2hWb2x1bWVS",
            "ZXNwb25zZSIAEmAKE05vZGVVbnB1Ymxpc2hWb2x1bWUSIi5jc2kudjAuTm9k",
            "ZVVucHVibGlzaFZvbHVtZVJlcXVlc3QaIy5jc2kudjAuTm9kZVVucHVibGlz",
            "aFZvbHVtZVJlc3BvbnNlIgASQgoJTm9kZUdldElkEhguY3NpLnYwLk5vZGVH",
            "ZXRJZFJlcXVlc3QaGS5jc2kudjAuTm9kZUdldElkUmVzcG9uc2UiABJgChNO",
            "b2RlR2V0Q2FwYWJpbGl0aWVzEiIuY3NpLnYwLk5vZGVHZXRDYXBhYmlsaXRp",
            "ZXNSZXF1ZXN0GiMuY3NpLnYwLk5vZGVHZXRDYXBhYmlsaXRpZXNSZXNwb25z",
            "ZSIAQgVaA2NzaWIGcHJvdG8z"));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { },
          new pbr::GeneratedClrTypeInfo(null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Csi.V0.GetPluginInfoRequest), global::Csi.V0.GetPluginInfoRequest.Parser, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Csi.V0.GetPluginInfoResponse), global::Csi.V0.GetPluginInfoResponse.Parser, new[]{ "Name", "VendorVersion", "Manifest" }, null, null, new pbr::GeneratedClrTypeInfo[] { null, }),
            new pbr::GeneratedClrTypeInfo(typeof(global::Csi.V0.GetPluginCapabilitiesRequest), global::Csi.V0.GetPluginCapabilitiesRequest.Parser, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Csi.V0.GetPluginCapabilitiesResponse), global::Csi.V0.GetPluginCapabilitiesResponse.Parser, new[]{ "Capabilities" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Csi.V0.PluginCapability), global::Csi.V0.PluginCapability.Parser, new[]{ "Service" }, new[]{ "Type" }, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Csi.V0.PluginCapability.Types.Service), global::Csi.V0.PluginCapability.Types.Service.Parser, new[]{ "Type" }, null, new[]{ typeof(global::Csi.V0.PluginCapability.Types.Service.Types.Type) }, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Csi.V0.ProbeRequest), global::Csi.V0.ProbeRequest.Parser, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Csi.V0.ProbeResponse), global::Csi.V0.ProbeResponse.Parser, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Csi.V0.CreateVolumeRequest), global::Csi.V0.CreateVolumeRequest.Parser, new[]{ "Name", "CapacityRange", "VolumeCapabilities", "Parameters", "ControllerCreateSecrets" }, null, null, new pbr::GeneratedClrTypeInfo[] { null, null, }),
            new pbr::GeneratedClrTypeInfo(typeof(global::Csi.V0.CreateVolumeResponse), global::Csi.V0.CreateVolumeResponse.Parser, new[]{ "Volume" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Csi.V0.VolumeCapability), global::Csi.V0.VolumeCapability.Parser, new[]{ "Block", "Mount", "AccessMode" }, new[]{ "AccessType" }, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Csi.V0.VolumeCapability.Types.BlockVolume), global::Csi.V0.VolumeCapability.Types.BlockVolume.Parser, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Csi.V0.VolumeCapability.Types.MountVolume), global::Csi.V0.VolumeCapability.Types.MountVolume.Parser, new[]{ "FsType", "MountFlags" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Csi.V0.VolumeCapability.Types.AccessMode), global::Csi.V0.VolumeCapability.Types.AccessMode.Parser, new[]{ "Mode" }, null, new[]{ typeof(global::Csi.V0.VolumeCapability.Types.AccessMode.Types.Mode) }, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Csi.V0.CapacityRange), global::Csi.V0.CapacityRange.Parser, new[]{ "RequiredBytes", "LimitBytes" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Csi.V0.Volume), global::Csi.V0.Volume.Parser, new[]{ "CapacityBytes", "Id", "Attributes" }, null, null, new pbr::GeneratedClrTypeInfo[] { null, }),
            new pbr::GeneratedClrTypeInfo(typeof(global::Csi.V0.DeleteVolumeRequest), global::Csi.V0.DeleteVolumeRequest.Parser, new[]{ "VolumeId", "ControllerDeleteSecrets" }, null, null, new pbr::GeneratedClrTypeInfo[] { null, }),
            new pbr::GeneratedClrTypeInfo(typeof(global::Csi.V0.DeleteVolumeResponse), global::Csi.V0.DeleteVolumeResponse.Parser, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Csi.V0.ControllerPublishVolumeRequest), global::Csi.V0.ControllerPublishVolumeRequest.Parser, new[]{ "VolumeId", "NodeId", "VolumeCapability", "Readonly", "ControllerPublishSecrets", "VolumeAttributes" }, null, null, new pbr::GeneratedClrTypeInfo[] { null, null, }),
            new pbr::GeneratedClrTypeInfo(typeof(global::Csi.V0.ControllerPublishVolumeResponse), global::Csi.V0.ControllerPublishVolumeResponse.Parser, new[]{ "PublishInfo" }, null, null, new pbr::GeneratedClrTypeInfo[] { null, }),
            new pbr::GeneratedClrTypeInfo(typeof(global::Csi.V0.ControllerUnpublishVolumeRequest), global::Csi.V0.ControllerUnpublishVolumeRequest.Parser, new[]{ "VolumeId", "NodeId", "ControllerUnpublishSecrets" }, null, null, new pbr::GeneratedClrTypeInfo[] { null, }),
            new pbr::GeneratedClrTypeInfo(typeof(global::Csi.V0.ControllerUnpublishVolumeResponse), global::Csi.V0.ControllerUnpublishVolumeResponse.Parser, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Csi.V0.ValidateVolumeCapabilitiesRequest), global::Csi.V0.ValidateVolumeCapabilitiesRequest.Parser, new[]{ "VolumeId", "VolumeCapabilities", "VolumeAttributes" }, null, null, new pbr::GeneratedClrTypeInfo[] { null, }),
            new pbr::GeneratedClrTypeInfo(typeof(global::Csi.V0.ValidateVolumeCapabilitiesResponse), global::Csi.V0.ValidateVolumeCapabilitiesResponse.Parser, new[]{ "Supported", "Message" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Csi.V0.ListVolumesRequest), global::Csi.V0.ListVolumesRequest.Parser, new[]{ "MaxEntries", "StartingToken" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Csi.V0.ListVolumesResponse), global::Csi.V0.ListVolumesResponse.Parser, new[]{ "Entries", "NextToken" }, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Csi.V0.ListVolumesResponse.Types.Entry), global::Csi.V0.ListVolumesResponse.Types.Entry.Parser, new[]{ "Volume" }, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Csi.V0.GetCapacityRequest), global::Csi.V0.GetCapacityRequest.Parser, new[]{ "VolumeCapabilities", "Parameters" }, null, null, new pbr::GeneratedClrTypeInfo[] { null, }),
            new pbr::GeneratedClrTypeInfo(typeof(global::Csi.V0.GetCapacityResponse), global::Csi.V0.GetCapacityResponse.Parser, new[]{ "AvailableCapacity" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Csi.V0.ControllerGetCapabilitiesRequest), global::Csi.V0.ControllerGetCapabilitiesRequest.Parser, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Csi.V0.ControllerGetCapabilitiesResponse), global::Csi.V0.ControllerGetCapabilitiesResponse.Parser, new[]{ "Capabilities" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Csi.V0.ControllerServiceCapability), global::Csi.V0.ControllerServiceCapability.Parser, new[]{ "Rpc" }, new[]{ "Type" }, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Csi.V0.ControllerServiceCapability.Types.RPC), global::Csi.V0.ControllerServiceCapability.Types.RPC.Parser, new[]{ "Type" }, null, new[]{ typeof(global::Csi.V0.ControllerServiceCapability.Types.RPC.Types.Type) }, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Csi.V0.NodeStageVolumeRequest), global::Csi.V0.NodeStageVolumeRequest.Parser, new[]{ "VolumeId", "PublishInfo", "StagingTargetPath", "VolumeCapability", "NodeStageSecrets", "VolumeAttributes" }, null, null, new pbr::GeneratedClrTypeInfo[] { null, null, null, }),
            new pbr::GeneratedClrTypeInfo(typeof(global::Csi.V0.NodeStageVolumeResponse), global::Csi.V0.NodeStageVolumeResponse.Parser, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Csi.V0.NodeUnstageVolumeRequest), global::Csi.V0.NodeUnstageVolumeRequest.Parser, new[]{ "VolumeId", "StagingTargetPath" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Csi.V0.NodeUnstageVolumeResponse), global::Csi.V0.NodeUnstageVolumeResponse.Parser, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Csi.V0.NodePublishVolumeRequest), global::Csi.V0.NodePublishVolumeRequest.Parser, new[]{ "VolumeId", "PublishInfo", "StagingTargetPath", "TargetPath", "VolumeCapability", "Readonly", "NodePublishSecrets", "VolumeAttributes" }, null, null, new pbr::GeneratedClrTypeInfo[] { null, null, null, }),
            new pbr::GeneratedClrTypeInfo(typeof(global::Csi.V0.NodePublishVolumeResponse), global::Csi.V0.NodePublishVolumeResponse.Parser, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Csi.V0.NodeUnpublishVolumeRequest), global::Csi.V0.NodeUnpublishVolumeRequest.Parser, new[]{ "VolumeId", "TargetPath" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Csi.V0.NodeUnpublishVolumeResponse), global::Csi.V0.NodeUnpublishVolumeResponse.Parser, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Csi.V0.NodeGetIdRequest), global::Csi.V0.NodeGetIdRequest.Parser, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Csi.V0.NodeGetIdResponse), global::Csi.V0.NodeGetIdResponse.Parser, new[]{ "NodeId" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Csi.V0.NodeGetCapabilitiesRequest), global::Csi.V0.NodeGetCapabilitiesRequest.Parser, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Csi.V0.NodeGetCapabilitiesResponse), global::Csi.V0.NodeGetCapabilitiesResponse.Parser, new[]{ "Capabilities" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Csi.V0.NodeServiceCapability), global::Csi.V0.NodeServiceCapability.Parser, new[]{ "Rpc" }, new[]{ "Type" }, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Csi.V0.NodeServiceCapability.Types.RPC), global::Csi.V0.NodeServiceCapability.Types.RPC.Parser, new[]{ "Type" }, null, new[]{ typeof(global::Csi.V0.NodeServiceCapability.Types.RPC.Types.Type) }, null)})
          }));
    }
    #endregion

  }
  #region Messages
  public sealed partial class GetPluginInfoRequest : pb::IMessage<GetPluginInfoRequest> {
    private static readonly pb::MessageParser<GetPluginInfoRequest> _parser = new pb::MessageParser<GetPluginInfoRequest>(() => new GetPluginInfoRequest());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<GetPluginInfoRequest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Csi.V0.CsiReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GetPluginInfoRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GetPluginInfoRequest(GetPluginInfoRequest other) : this() {
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GetPluginInfoRequest Clone() {
      return new GetPluginInfoRequest(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as GetPluginInfoRequest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(GetPluginInfoRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(GetPluginInfoRequest other) {
      if (other == null) {
        return;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
        }
      }
    }

  }

  public sealed partial class GetPluginInfoResponse : pb::IMessage<GetPluginInfoResponse> {
    private static readonly pb::MessageParser<GetPluginInfoResponse> _parser = new pb::MessageParser<GetPluginInfoResponse>(() => new GetPluginInfoResponse());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<GetPluginInfoResponse> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Csi.V0.CsiReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GetPluginInfoResponse() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GetPluginInfoResponse(GetPluginInfoResponse other) : this() {
      name_ = other.name_;
      vendorVersion_ = other.vendorVersion_;
      manifest_ = other.manifest_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GetPluginInfoResponse Clone() {
      return new GetPluginInfoResponse(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private string name_ = "";
    /// <summary>
    /// The name MUST follow reverse domain name notation format
    /// (https://en.wikipedia.org/wiki/Reverse_domain_name_notation).
    /// It SHOULD include the plugin's host company name and the plugin
    /// name, to minimize the possibility of collisions. It MUST be 63
    /// characters or less, beginning and ending with an alphanumeric
    /// character ([a-z0-9A-Z]) with dashes (-), underscores (_),
    /// dots (.), and alphanumerics between. This field is REQUIRED.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "vendor_version" field.</summary>
    public const int VendorVersionFieldNumber = 2;
    private string vendorVersion_ = "";
    /// <summary>
    /// This field is REQUIRED. Value of this field is opaque to the CO.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string VendorVersion {
      get { return vendorVersion_; }
      set {
        vendorVersion_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "manifest" field.</summary>
    public const int ManifestFieldNumber = 3;
    private static readonly pbc::MapField<string, string>.Codec _map_manifest_codec
        = new pbc::MapField<string, string>.Codec(pb::FieldCodec.ForString(10), pb::FieldCodec.ForString(18), 26);
    private readonly pbc::MapField<string, string> manifest_ = new pbc::MapField<string, string>();
    /// <summary>
    /// This field is OPTIONAL. Values are opaque to the CO.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::MapField<string, string> Manifest {
      get { return manifest_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as GetPluginInfoResponse);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(GetPluginInfoResponse other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (VendorVersion != other.VendorVersion) return false;
      if (!Manifest.Equals(other.Manifest)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (VendorVersion.Length != 0) hash ^= VendorVersion.GetHashCode();
      hash ^= Manifest.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (VendorVersion.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(VendorVersion);
      }
      manifest_.WriteTo(output, _map_manifest_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (VendorVersion.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(VendorVersion);
      }
      size += manifest_.CalculateSize(_map_manifest_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(GetPluginInfoResponse other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.VendorVersion.Length != 0) {
        VendorVersion = other.VendorVersion;
      }
      manifest_.Add(other.manifest_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            VendorVersion = input.ReadString();
            break;
          }
          case 26: {
            manifest_.AddEntriesFrom(input, _map_manifest_codec);
            break;
          }
        }
      }
    }

  }

  public sealed partial class GetPluginCapabilitiesRequest : pb::IMessage<GetPluginCapabilitiesRequest> {
    private static readonly pb::MessageParser<GetPluginCapabilitiesRequest> _parser = new pb::MessageParser<GetPluginCapabilitiesRequest>(() => new GetPluginCapabilitiesRequest());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<GetPluginCapabilitiesRequest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Csi.V0.CsiReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GetPluginCapabilitiesRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GetPluginCapabilitiesRequest(GetPluginCapabilitiesRequest other) : this() {
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GetPluginCapabilitiesRequest Clone() {
      return new GetPluginCapabilitiesRequest(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as GetPluginCapabilitiesRequest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(GetPluginCapabilitiesRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(GetPluginCapabilitiesRequest other) {
      if (other == null) {
        return;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
        }
      }
    }

  }

  public sealed partial class GetPluginCapabilitiesResponse : pb::IMessage<GetPluginCapabilitiesResponse> {
    private static readonly pb::MessageParser<GetPluginCapabilitiesResponse> _parser = new pb::MessageParser<GetPluginCapabilitiesResponse>(() => new GetPluginCapabilitiesResponse());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<GetPluginCapabilitiesResponse> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Csi.V0.CsiReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GetPluginCapabilitiesResponse() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GetPluginCapabilitiesResponse(GetPluginCapabilitiesResponse other) : this() {
      capabilities_ = other.capabilities_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GetPluginCapabilitiesResponse Clone() {
      return new GetPluginCapabilitiesResponse(this);
    }

    /// <summary>Field number for the "capabilities" field.</summary>
    public const int CapabilitiesFieldNumber = 2;
    private static readonly pb::FieldCodec<global::Csi.V0.PluginCapability> _repeated_capabilities_codec
        = pb::FieldCodec.ForMessage(18, global::Csi.V0.PluginCapability.Parser);
    private readonly pbc::RepeatedField<global::Csi.V0.PluginCapability> capabilities_ = new pbc::RepeatedField<global::Csi.V0.PluginCapability>();
    /// <summary>
    /// All the capabilities that the controller service supports. This
    /// field is OPTIONAL.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Csi.V0.PluginCapability> Capabilities {
      get { return capabilities_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as GetPluginCapabilitiesResponse);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(GetPluginCapabilitiesResponse other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!capabilities_.Equals(other.capabilities_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= capabilities_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      capabilities_.WriteTo(output, _repeated_capabilities_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += capabilities_.CalculateSize(_repeated_capabilities_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(GetPluginCapabilitiesResponse other) {
      if (other == null) {
        return;
      }
      capabilities_.Add(other.capabilities_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 18: {
            capabilities_.AddEntriesFrom(input, _repeated_capabilities_codec);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Specifies a capability of the plugin.
  /// </summary>
  public sealed partial class PluginCapability : pb::IMessage<PluginCapability> {
    private static readonly pb::MessageParser<PluginCapability> _parser = new pb::MessageParser<PluginCapability>(() => new PluginCapability());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<PluginCapability> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Csi.V0.CsiReflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public PluginCapability() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public PluginCapability(PluginCapability other) : this() {
      switch (other.TypeCase) {
        case TypeOneofCase.Service:
          Service = other.Service.Clone();
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public PluginCapability Clone() {
      return new PluginCapability(this);
    }

    /// <summary>Field number for the "service" field.</summary>
    public const int ServiceFieldNumber = 1;
    /// <summary>
    /// Service that the plugin supports.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Csi.V0.PluginCapability.Types.Service Service {
      get { return typeCase_ == TypeOneofCase.Service ? (global::Csi.V0.PluginCapability.Types.Service) type_ : null; }
      set {
        type_ = value;
        typeCase_ = value == null ? TypeOneofCase.None : TypeOneofCase.Service;
      }
    }

    private object type_;
    /// <summary>Enum of possible cases for the "type" oneof.</summary>
    public enum TypeOneofCase {
      None = 0,
      Service = 1,
    }
    private TypeOneofCase typeCase_ = TypeOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TypeOneofCase TypeCase {
      get { return typeCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearType() {
      typeCase_ = TypeOneofCase.None;
      type_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as PluginCapability);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(PluginCapability other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Service, other.Service)) return false;
      if (TypeCase != other.TypeCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (typeCase_ == TypeOneofCase.Service) hash ^= Service.GetHashCode();
      hash ^= (int) typeCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (typeCase_ == TypeOneofCase.Service) {
        output.WriteRawTag(10);
        output.WriteMessage(Service);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (typeCase_ == TypeOneofCase.Service) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Service);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(PluginCapability other) {
      if (other == null) {
        return;
      }
      switch (other.TypeCase) {
        case TypeOneofCase.Service:
          if (Service == null) {
            Service = new global::Csi.V0.PluginCapability.Types.Service();
          }
          Service.MergeFrom(other.Service);
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            global::Csi.V0.PluginCapability.Types.Service subBuilder = new global::Csi.V0.PluginCapability.Types.Service();
            if (typeCase_ == TypeOneofCase.Service) {
              subBuilder.MergeFrom(Service);
            }
            input.ReadMessage(subBuilder);
            Service = subBuilder;
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the PluginCapability message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      public sealed partial class Service : pb::IMessage<Service> {
        private static readonly pb::MessageParser<Service> _parser = new pb::MessageParser<Service>(() => new Service());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Service> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Csi.V0.PluginCapability.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Service() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Service(Service other) : this() {
          type_ = other.type_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Service Clone() {
          return new Service(this);
        }

        /// <summary>Field number for the "type" field.</summary>
        public const int TypeFieldNumber = 1;
        private global::Csi.V0.PluginCapability.Types.Service.Types.Type type_ = 0;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Csi.V0.PluginCapability.Types.Service.Types.Type Type {
          get { return type_; }
          set {
            type_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as Service);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Service other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Type != other.Type) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (Type != 0) hash ^= Type.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (Type != 0) {
            output.WriteRawTag(8);
            output.WriteEnum((int) Type);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (Type != 0) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Type);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Service other) {
          if (other == null) {
            return;
          }
          if (other.Type != 0) {
            Type = other.Type;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                type_ = (global::Csi.V0.PluginCapability.Types.Service.Types.Type) input.ReadEnum();
                break;
              }
            }
          }
        }

        #region Nested types
        /// <summary>Container for nested types declared in the Service message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static partial class Types {
          public enum Type {
            [pbr::OriginalName("UNKNOWN")] Unknown = 0,
            /// <summary>
            /// CONTROLLER_SERVICE indicates that the Plugin provides RPCs for
            /// the ControllerService. Plugins SHOULD provide this capability.
            /// In rare cases certain plugins may wish to omit the
            /// ControllerService entirely from their implementation, but such
            /// SHOULD NOT be the common case.
            /// The presence of this capability determines whether the CO will
            /// attempt to invoke the REQUIRED ControllerService RPCs, as well
            /// as specific RPCs as indicated by ControllerGetCapabilities.
            /// </summary>
            [pbr::OriginalName("CONTROLLER_SERVICE")] ControllerService = 1,
          }

        }
        #endregion

      }

    }
    #endregion

  }

  public sealed partial class ProbeRequest : pb::IMessage<ProbeRequest> {
    private static readonly pb::MessageParser<ProbeRequest> _parser = new pb::MessageParser<ProbeRequest>(() => new ProbeRequest());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ProbeRequest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Csi.V0.CsiReflection.Descriptor.MessageTypes[5]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ProbeRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ProbeRequest(ProbeRequest other) : this() {
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ProbeRequest Clone() {
      return new ProbeRequest(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ProbeRequest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ProbeRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ProbeRequest other) {
      if (other == null) {
        return;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
        }
      }
    }

  }

  /// <summary>
  /// Intentionally empty.
  /// </summary>
  public sealed partial class ProbeResponse : pb::IMessage<ProbeResponse> {
    private static readonly pb::MessageParser<ProbeResponse> _parser = new pb::MessageParser<ProbeResponse>(() => new ProbeResponse());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ProbeResponse> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Csi.V0.CsiReflection.Descriptor.MessageTypes[6]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ProbeResponse() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ProbeResponse(ProbeResponse other) : this() {
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ProbeResponse Clone() {
      return new ProbeResponse(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ProbeResponse);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ProbeResponse other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ProbeResponse other) {
      if (other == null) {
        return;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
        }
      }
    }

  }

  public sealed partial class CreateVolumeRequest : pb::IMessage<CreateVolumeRequest> {
    private static readonly pb::MessageParser<CreateVolumeRequest> _parser = new pb::MessageParser<CreateVolumeRequest>(() => new CreateVolumeRequest());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<CreateVolumeRequest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Csi.V0.CsiReflection.Descriptor.MessageTypes[7]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CreateVolumeRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CreateVolumeRequest(CreateVolumeRequest other) : this() {
      name_ = other.name_;
      CapacityRange = other.capacityRange_ != null ? other.CapacityRange.Clone() : null;
      volumeCapabilities_ = other.volumeCapabilities_.Clone();
      parameters_ = other.parameters_.Clone();
      controllerCreateSecrets_ = other.controllerCreateSecrets_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CreateVolumeRequest Clone() {
      return new CreateVolumeRequest(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private string name_ = "";
    /// <summary>
    /// The suggested name for the storage space. This field is REQUIRED.
    /// It serves two purposes:
    /// 1) Idempotency - This name is generated by the CO to achieve
    ///    idempotency. If `CreateVolume` fails, the volume may or may not
    ///    be provisioned. In this case, the CO may call `CreateVolume`
    ///    again, with the same name, to ensure the volume exists. The
    ///    Plugin should ensure that multiple `CreateVolume` calls for the
    ///    same name do not result in more than one piece of storage
    ///    provisioned corresponding to that name. If a Plugin is unable to
    ///    enforce idempotency, the CO's error recovery logic could result
    ///    in multiple (unused) volumes being provisioned.
    /// 2) Suggested name - Some storage systems allow callers to specify
    ///    an identifier by which to refer to the newly provisioned
    ///    storage. If a storage system supports this, it can optionally
    ///    use this name as the identifier for the new volume.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "capacity_range" field.</summary>
    public const int CapacityRangeFieldNumber = 2;
    private global::Csi.V0.CapacityRange capacityRange_;
    /// <summary>
    /// This field is OPTIONAL. This allows the CO to specify the capacity
    /// requirement of the volume to be provisioned. If not specified, the
    /// Plugin MAY choose an implementation-defined capacity range.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Csi.V0.CapacityRange CapacityRange {
      get { return capacityRange_; }
      set {
        capacityRange_ = value;
      }
    }

    /// <summary>Field number for the "volume_capabilities" field.</summary>
    public const int VolumeCapabilitiesFieldNumber = 3;
    private static readonly pb::FieldCodec<global::Csi.V0.VolumeCapability> _repeated_volumeCapabilities_codec
        = pb::FieldCodec.ForMessage(26, global::Csi.V0.VolumeCapability.Parser);
    private readonly pbc::RepeatedField<global::Csi.V0.VolumeCapability> volumeCapabilities_ = new pbc::RepeatedField<global::Csi.V0.VolumeCapability>();
    /// <summary>
    /// The capabilities that the provisioned volume MUST have: the Plugin
    /// MUST provision a volume that could satisfy ALL of the
    /// capabilities specified in this list. The Plugin MUST assume that
    /// the CO MAY use the  provisioned volume later with ANY of the
    /// capabilities specified in this list. This also enables the CO to do
    /// early validation: if ANY of the specified volume capabilities are
    /// not supported by the Plugin, the call SHALL fail. This field is
    /// REQUIRED.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Csi.V0.VolumeCapability> VolumeCapabilities {
      get { return volumeCapabilities_; }
    }

    /// <summary>Field number for the "parameters" field.</summary>
    public const int ParametersFieldNumber = 4;
    private static readonly pbc::MapField<string, string>.Codec _map_parameters_codec
        = new pbc::MapField<string, string>.Codec(pb::FieldCodec.ForString(10), pb::FieldCodec.ForString(18), 34);
    private readonly pbc::MapField<string, string> parameters_ = new pbc::MapField<string, string>();
    /// <summary>
    /// Plugin specific parameters passed in as opaque key-value pairs.
    /// This field is OPTIONAL. The Plugin is responsible for parsing and
    /// validating these parameters. COs will treat these as opaque.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::MapField<string, string> Parameters {
      get { return parameters_; }
    }

    /// <summary>Field number for the "controller_create_secrets" field.</summary>
    public const int ControllerCreateSecretsFieldNumber = 5;
    private static readonly pbc::MapField<string, string>.Codec _map_controllerCreateSecrets_codec
        = new pbc::MapField<string, string>.Codec(pb::FieldCodec.ForString(10), pb::FieldCodec.ForString(18), 42);
    private readonly pbc::MapField<string, string> controllerCreateSecrets_ = new pbc::MapField<string, string>();
    /// <summary>
    /// Secrets required by plugin to complete volume creation request.
    /// A secret is a string to string map where the key identifies the
    /// name of the secret (e.g. "username" or "password"), and the value
    /// contains the secret data (e.g. "bob" or "abc123").
    /// Each key MUST consist of alphanumeric characters, '-', '_' or '.'.
    /// Each value MUST contain a valid string. An SP MAY choose to accept
    /// binary (non-string) data by using a binary-to-text encoding scheme,
    /// like base64.
    /// An SP SHALL advertise the requirements for required secret keys and
    /// values in documentation.
    /// CO SHALL permit passing through the required secrets.
    /// A CO MAY pass the same secrets to all RPCs, therefore the keys for
    /// all unique secrets that an SP expects must be unique across all CSI
    /// operations.
    /// This information is sensitive and MUST be treated as such (not
    /// logged, etc.) by the CO.
    /// This field is OPTIONAL.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::MapField<string, string> ControllerCreateSecrets {
      get { return controllerCreateSecrets_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as CreateVolumeRequest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(CreateVolumeRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (!object.Equals(CapacityRange, other.CapacityRange)) return false;
      if(!volumeCapabilities_.Equals(other.volumeCapabilities_)) return false;
      if (!Parameters.Equals(other.Parameters)) return false;
      if (!ControllerCreateSecrets.Equals(other.ControllerCreateSecrets)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (capacityRange_ != null) hash ^= CapacityRange.GetHashCode();
      hash ^= volumeCapabilities_.GetHashCode();
      hash ^= Parameters.GetHashCode();
      hash ^= ControllerCreateSecrets.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (capacityRange_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(CapacityRange);
      }
      volumeCapabilities_.WriteTo(output, _repeated_volumeCapabilities_codec);
      parameters_.WriteTo(output, _map_parameters_codec);
      controllerCreateSecrets_.WriteTo(output, _map_controllerCreateSecrets_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (capacityRange_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(CapacityRange);
      }
      size += volumeCapabilities_.CalculateSize(_repeated_volumeCapabilities_codec);
      size += parameters_.CalculateSize(_map_parameters_codec);
      size += controllerCreateSecrets_.CalculateSize(_map_controllerCreateSecrets_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(CreateVolumeRequest other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.capacityRange_ != null) {
        if (capacityRange_ == null) {
          capacityRange_ = new global::Csi.V0.CapacityRange();
        }
        CapacityRange.MergeFrom(other.CapacityRange);
      }
      volumeCapabilities_.Add(other.volumeCapabilities_);
      parameters_.Add(other.parameters_);
      controllerCreateSecrets_.Add(other.controllerCreateSecrets_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            if (capacityRange_ == null) {
              capacityRange_ = new global::Csi.V0.CapacityRange();
            }
            input.ReadMessage(capacityRange_);
            break;
          }
          case 26: {
            volumeCapabilities_.AddEntriesFrom(input, _repeated_volumeCapabilities_codec);
            break;
          }
          case 34: {
            parameters_.AddEntriesFrom(input, _map_parameters_codec);
            break;
          }
          case 42: {
            controllerCreateSecrets_.AddEntriesFrom(input, _map_controllerCreateSecrets_codec);
            break;
          }
        }
      }
    }

  }

  public sealed partial class CreateVolumeResponse : pb::IMessage<CreateVolumeResponse> {
    private static readonly pb::MessageParser<CreateVolumeResponse> _parser = new pb::MessageParser<CreateVolumeResponse>(() => new CreateVolumeResponse());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<CreateVolumeResponse> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Csi.V0.CsiReflection.Descriptor.MessageTypes[8]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CreateVolumeResponse() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CreateVolumeResponse(CreateVolumeResponse other) : this() {
      Volume = other.volume_ != null ? other.Volume.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CreateVolumeResponse Clone() {
      return new CreateVolumeResponse(this);
    }

    /// <summary>Field number for the "volume" field.</summary>
    public const int VolumeFieldNumber = 1;
    private global::Csi.V0.Volume volume_;
    /// <summary>
    /// Contains all attributes of the newly created volume that are
    /// relevant to the CO along with information required by the Plugin
    /// to uniquely identify the volume. This field is REQUIRED.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Csi.V0.Volume Volume {
      get { return volume_; }
      set {
        volume_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as CreateVolumeResponse);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(CreateVolumeResponse other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Volume, other.Volume)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (volume_ != null) hash ^= Volume.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (volume_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Volume);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (volume_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Volume);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(CreateVolumeResponse other) {
      if (other == null) {
        return;
      }
      if (other.volume_ != null) {
        if (volume_ == null) {
          volume_ = new global::Csi.V0.Volume();
        }
        Volume.MergeFrom(other.Volume);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (volume_ == null) {
              volume_ = new global::Csi.V0.Volume();
            }
            input.ReadMessage(volume_);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Specify a capability of a volume.
  /// </summary>
  public sealed partial class VolumeCapability : pb::IMessage<VolumeCapability> {
    private static readonly pb::MessageParser<VolumeCapability> _parser = new pb::MessageParser<VolumeCapability>(() => new VolumeCapability());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<VolumeCapability> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Csi.V0.CsiReflection.Descriptor.MessageTypes[9]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public VolumeCapability() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public VolumeCapability(VolumeCapability other) : this() {
      AccessMode = other.accessMode_ != null ? other.AccessMode.Clone() : null;
      switch (other.AccessTypeCase) {
        case AccessTypeOneofCase.Block:
          Block = other.Block.Clone();
          break;
        case AccessTypeOneofCase.Mount:
          Mount = other.Mount.Clone();
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public VolumeCapability Clone() {
      return new VolumeCapability(this);
    }

    /// <summary>Field number for the "block" field.</summary>
    public const int BlockFieldNumber = 1;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Csi.V0.VolumeCapability.Types.BlockVolume Block {
      get { return accessTypeCase_ == AccessTypeOneofCase.Block ? (global::Csi.V0.VolumeCapability.Types.BlockVolume) accessType_ : null; }
      set {
        accessType_ = value;
        accessTypeCase_ = value == null ? AccessTypeOneofCase.None : AccessTypeOneofCase.Block;
      }
    }

    /// <summary>Field number for the "mount" field.</summary>
    public const int MountFieldNumber = 2;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Csi.V0.VolumeCapability.Types.MountVolume Mount {
      get { return accessTypeCase_ == AccessTypeOneofCase.Mount ? (global::Csi.V0.VolumeCapability.Types.MountVolume) accessType_ : null; }
      set {
        accessType_ = value;
        accessTypeCase_ = value == null ? AccessTypeOneofCase.None : AccessTypeOneofCase.Mount;
      }
    }

    /// <summary>Field number for the "access_mode" field.</summary>
    public const int AccessModeFieldNumber = 3;
    private global::Csi.V0.VolumeCapability.Types.AccessMode accessMode_;
    /// <summary>
    /// This is a REQUIRED field.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Csi.V0.VolumeCapability.Types.AccessMode AccessMode {
      get { return accessMode_; }
      set {
        accessMode_ = value;
      }
    }

    private object accessType_;
    /// <summary>Enum of possible cases for the "access_type" oneof.</summary>
    public enum AccessTypeOneofCase {
      None = 0,
      Block = 1,
      Mount = 2,
    }
    private AccessTypeOneofCase accessTypeCase_ = AccessTypeOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AccessTypeOneofCase AccessTypeCase {
      get { return accessTypeCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearAccessType() {
      accessTypeCase_ = AccessTypeOneofCase.None;
      accessType_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as VolumeCapability);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(VolumeCapability other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Block, other.Block)) return false;
      if (!object.Equals(Mount, other.Mount)) return false;
      if (!object.Equals(AccessMode, other.AccessMode)) return false;
      if (AccessTypeCase != other.AccessTypeCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (accessTypeCase_ == AccessTypeOneofCase.Block) hash ^= Block.GetHashCode();
      if (accessTypeCase_ == AccessTypeOneofCase.Mount) hash ^= Mount.GetHashCode();
      if (accessMode_ != null) hash ^= AccessMode.GetHashCode();
      hash ^= (int) accessTypeCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (accessTypeCase_ == AccessTypeOneofCase.Block) {
        output.WriteRawTag(10);
        output.WriteMessage(Block);
      }
      if (accessTypeCase_ == AccessTypeOneofCase.Mount) {
        output.WriteRawTag(18);
        output.WriteMessage(Mount);
      }
      if (accessMode_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(AccessMode);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (accessTypeCase_ == AccessTypeOneofCase.Block) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Block);
      }
      if (accessTypeCase_ == AccessTypeOneofCase.Mount) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Mount);
      }
      if (accessMode_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(AccessMode);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(VolumeCapability other) {
      if (other == null) {
        return;
      }
      if (other.accessMode_ != null) {
        if (accessMode_ == null) {
          accessMode_ = new global::Csi.V0.VolumeCapability.Types.AccessMode();
        }
        AccessMode.MergeFrom(other.AccessMode);
      }
      switch (other.AccessTypeCase) {
        case AccessTypeOneofCase.Block:
          if (Block == null) {
            Block = new global::Csi.V0.VolumeCapability.Types.BlockVolume();
          }
          Block.MergeFrom(other.Block);
          break;
        case AccessTypeOneofCase.Mount:
          if (Mount == null) {
            Mount = new global::Csi.V0.VolumeCapability.Types.MountVolume();
          }
          Mount.MergeFrom(other.Mount);
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            global::Csi.V0.VolumeCapability.Types.BlockVolume subBuilder = new global::Csi.V0.VolumeCapability.Types.BlockVolume();
            if (accessTypeCase_ == AccessTypeOneofCase.Block) {
              subBuilder.MergeFrom(Block);
            }
            input.ReadMessage(subBuilder);
            Block = subBuilder;
            break;
          }
          case 18: {
            global::Csi.V0.VolumeCapability.Types.MountVolume subBuilder = new global::Csi.V0.VolumeCapability.Types.MountVolume();
            if (accessTypeCase_ == AccessTypeOneofCase.Mount) {
              subBuilder.MergeFrom(Mount);
            }
            input.ReadMessage(subBuilder);
            Mount = subBuilder;
            break;
          }
          case 26: {
            if (accessMode_ == null) {
              accessMode_ = new global::Csi.V0.VolumeCapability.Types.AccessMode();
            }
            input.ReadMessage(accessMode_);
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the VolumeCapability message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// Indicate that the volume will be accessed via the block device API.
      /// </summary>
      public sealed partial class BlockVolume : pb::IMessage<BlockVolume> {
        private static readonly pb::MessageParser<BlockVolume> _parser = new pb::MessageParser<BlockVolume>(() => new BlockVolume());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<BlockVolume> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Csi.V0.VolumeCapability.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public BlockVolume() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public BlockVolume(BlockVolume other) : this() {
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public BlockVolume Clone() {
          return new BlockVolume(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as BlockVolume);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(BlockVolume other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(BlockVolume other) {
          if (other == null) {
            return;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
            }
          }
        }

      }

      /// <summary>
      /// Indicate that the volume will be accessed via the filesystem API.
      /// </summary>
      public sealed partial class MountVolume : pb::IMessage<MountVolume> {
        private static readonly pb::MessageParser<MountVolume> _parser = new pb::MessageParser<MountVolume>(() => new MountVolume());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<MountVolume> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Csi.V0.VolumeCapability.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public MountVolume() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public MountVolume(MountVolume other) : this() {
          fsType_ = other.fsType_;
          mountFlags_ = other.mountFlags_.Clone();
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public MountVolume Clone() {
          return new MountVolume(this);
        }

        /// <summary>Field number for the "fs_type" field.</summary>
        public const int FsTypeFieldNumber = 1;
        private string fsType_ = "";
        /// <summary>
        /// The filesystem type. This field is OPTIONAL.
        /// An empty string is equal to an unspecified field value.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string FsType {
          get { return fsType_; }
          set {
            fsType_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "mount_flags" field.</summary>
        public const int MountFlagsFieldNumber = 2;
        private static readonly pb::FieldCodec<string> _repeated_mountFlags_codec
            = pb::FieldCodec.ForString(18);
        private readonly pbc::RepeatedField<string> mountFlags_ = new pbc::RepeatedField<string>();
        /// <summary>
        /// The mount options that can be used for the volume. This field is
        /// OPTIONAL. `mount_flags` MAY contain sensitive information.
        /// Therefore, the CO and the Plugin MUST NOT leak this information
        /// to untrusted entities. The total size of this repeated field
        /// SHALL NOT exceed 4 KiB.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<string> MountFlags {
          get { return mountFlags_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as MountVolume);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(MountVolume other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (FsType != other.FsType) return false;
          if(!mountFlags_.Equals(other.mountFlags_)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (FsType.Length != 0) hash ^= FsType.GetHashCode();
          hash ^= mountFlags_.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (FsType.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(FsType);
          }
          mountFlags_.WriteTo(output, _repeated_mountFlags_codec);
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (FsType.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(FsType);
          }
          size += mountFlags_.CalculateSize(_repeated_mountFlags_codec);
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(MountVolume other) {
          if (other == null) {
            return;
          }
          if (other.FsType.Length != 0) {
            FsType = other.FsType;
          }
          mountFlags_.Add(other.mountFlags_);
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                FsType = input.ReadString();
                break;
              }
              case 18: {
                mountFlags_.AddEntriesFrom(input, _repeated_mountFlags_codec);
                break;
              }
            }
          }
        }

      }

      /// <summary>
      /// Specify how a volume can be accessed.
      /// </summary>
      public sealed partial class AccessMode : pb::IMessage<AccessMode> {
        private static readonly pb::MessageParser<AccessMode> _parser = new pb::MessageParser<AccessMode>(() => new AccessMode());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<AccessMode> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Csi.V0.VolumeCapability.Descriptor.NestedTypes[2]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public AccessMode() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public AccessMode(AccessMode other) : this() {
          mode_ = other.mode_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public AccessMode Clone() {
          return new AccessMode(this);
        }

        /// <summary>Field number for the "mode" field.</summary>
        public const int ModeFieldNumber = 1;
        private global::Csi.V0.VolumeCapability.Types.AccessMode.Types.Mode mode_ = 0;
        /// <summary>
        /// This field is REQUIRED.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Csi.V0.VolumeCapability.Types.AccessMode.Types.Mode Mode {
          get { return mode_; }
          set {
            mode_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as AccessMode);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(AccessMode other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Mode != other.Mode) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (Mode != 0) hash ^= Mode.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (Mode != 0) {
            output.WriteRawTag(8);
            output.WriteEnum((int) Mode);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (Mode != 0) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Mode);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(AccessMode other) {
          if (other == null) {
            return;
          }
          if (other.Mode != 0) {
            Mode = other.Mode;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                mode_ = (global::Csi.V0.VolumeCapability.Types.AccessMode.Types.Mode) input.ReadEnum();
                break;
              }
            }
          }
        }

        #region Nested types
        /// <summary>Container for nested types declared in the AccessMode message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static partial class Types {
          public enum Mode {
            [pbr::OriginalName("UNKNOWN")] Unknown = 0,
            /// <summary>
            /// Can only be published once as read/write on a single node, at
            /// any given time.
            /// </summary>
            [pbr::OriginalName("SINGLE_NODE_WRITER")] SingleNodeWriter = 1,
            /// <summary>
            /// Can only be published once as readonly on a single node, at
            /// any given time.
            /// </summary>
            [pbr::OriginalName("SINGLE_NODE_READER_ONLY")] SingleNodeReaderOnly = 2,
            /// <summary>
            /// Can be published as readonly at multiple nodes simultaneously.
            /// </summary>
            [pbr::OriginalName("MULTI_NODE_READER_ONLY")] MultiNodeReaderOnly = 3,
            /// <summary>
            /// Can be published at multiple nodes simultaneously. Only one of
            /// the node can be used as read/write. The rest will be readonly.
            /// </summary>
            [pbr::OriginalName("MULTI_NODE_SINGLE_WRITER")] MultiNodeSingleWriter = 4,
            /// <summary>
            /// Can be published as read/write at multiple nodes
            /// simultaneously.
            /// </summary>
            [pbr::OriginalName("MULTI_NODE_MULTI_WRITER")] MultiNodeMultiWriter = 5,
          }

        }
        #endregion

      }

    }
    #endregion

  }

  /// <summary>
  /// The capacity of the storage space in bytes. To specify an exact size,
  /// `required_bytes` and `limit_bytes` can be set to the same value. At
  /// least one of the these fields MUST be specified.
  /// </summary>
  public sealed partial class CapacityRange : pb::IMessage<CapacityRange> {
    private static readonly pb::MessageParser<CapacityRange> _parser = new pb::MessageParser<CapacityRange>(() => new CapacityRange());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<CapacityRange> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Csi.V0.CsiReflection.Descriptor.MessageTypes[10]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CapacityRange() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CapacityRange(CapacityRange other) : this() {
      requiredBytes_ = other.requiredBytes_;
      limitBytes_ = other.limitBytes_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CapacityRange Clone() {
      return new CapacityRange(this);
    }

    /// <summary>Field number for the "required_bytes" field.</summary>
    public const int RequiredBytesFieldNumber = 1;
    private long requiredBytes_;
    /// <summary>
    /// Volume must be at least this big. This field is OPTIONAL.
    /// A value of 0 is equal to an unspecified field value.
    /// The value of this field MUST NOT be negative. 
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long RequiredBytes {
      get { return requiredBytes_; }
      set {
        requiredBytes_ = value;
      }
    }

    /// <summary>Field number for the "limit_bytes" field.</summary>
    public const int LimitBytesFieldNumber = 2;
    private long limitBytes_;
    /// <summary>
    /// Volume must not be bigger than this. This field is OPTIONAL.
    /// A value of 0 is equal to an unspecified field value.
    /// The value of this field MUST NOT be negative. 
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long LimitBytes {
      get { return limitBytes_; }
      set {
        limitBytes_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as CapacityRange);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(CapacityRange other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (RequiredBytes != other.RequiredBytes) return false;
      if (LimitBytes != other.LimitBytes) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (RequiredBytes != 0L) hash ^= RequiredBytes.GetHashCode();
      if (LimitBytes != 0L) hash ^= LimitBytes.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (RequiredBytes != 0L) {
        output.WriteRawTag(8);
        output.WriteInt64(RequiredBytes);
      }
      if (LimitBytes != 0L) {
        output.WriteRawTag(16);
        output.WriteInt64(LimitBytes);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (RequiredBytes != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(RequiredBytes);
      }
      if (LimitBytes != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(LimitBytes);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(CapacityRange other) {
      if (other == null) {
        return;
      }
      if (other.RequiredBytes != 0L) {
        RequiredBytes = other.RequiredBytes;
      }
      if (other.LimitBytes != 0L) {
        LimitBytes = other.LimitBytes;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            RequiredBytes = input.ReadInt64();
            break;
          }
          case 16: {
            LimitBytes = input.ReadInt64();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// The information about a provisioned volume.
  /// </summary>
  public sealed partial class Volume : pb::IMessage<Volume> {
    private static readonly pb::MessageParser<Volume> _parser = new pb::MessageParser<Volume>(() => new Volume());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Volume> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Csi.V0.CsiReflection.Descriptor.MessageTypes[11]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Volume() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Volume(Volume other) : this() {
      capacityBytes_ = other.capacityBytes_;
      id_ = other.id_;
      attributes_ = other.attributes_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Volume Clone() {
      return new Volume(this);
    }

    /// <summary>Field number for the "capacity_bytes" field.</summary>
    public const int CapacityBytesFieldNumber = 1;
    private long capacityBytes_;
    /// <summary>
    /// The capacity of the volume in bytes. This field is OPTIONAL. If not
    /// set (value of 0), it indicates that the capacity of the volume is
    /// unknown (e.g., NFS share).
    /// The value of this field MUST NOT be negative. 
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long CapacityBytes {
      get { return capacityBytes_; }
      set {
        capacityBytes_ = value;
      }
    }

    /// <summary>Field number for the "id" field.</summary>
    public const int IdFieldNumber = 2;
    private string id_ = "";
    /// <summary>
    /// Contains identity information for the created volume. This field is
    /// REQUIRED. The identity information will be used by the CO in
    /// subsequent calls to refer to the provisioned volume.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Id {
      get { return id_; }
      set {
        id_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "attributes" field.</summary>
    public const int AttributesFieldNumber = 3;
    private static readonly pbc::MapField<string, string>.Codec _map_attributes_codec
        = new pbc::MapField<string, string>.Codec(pb::FieldCodec.ForString(10), pb::FieldCodec.ForString(18), 26);
    private readonly pbc::MapField<string, string> attributes_ = new pbc::MapField<string, string>();
    /// <summary>
    /// Attributes reflect static properties of a volume and MUST be passed
    /// to volume validation and publishing calls.
    /// Attributes SHALL be opaque to a CO. Attributes SHALL NOT be mutable
    /// and SHALL be safe for the CO to cache. Attributes SHOULD NOT
    /// contain sensitive information. Attributes MAY NOT uniquely identify
    /// a volume. A volume uniquely identified by `id` SHALL always report
    /// the same attributes. This field is OPTIONAL and when present MUST
    /// be passed to volume validation and publishing calls.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::MapField<string, string> Attributes {
      get { return attributes_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Volume);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Volume other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (CapacityBytes != other.CapacityBytes) return false;
      if (Id != other.Id) return false;
      if (!Attributes.Equals(other.Attributes)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (CapacityBytes != 0L) hash ^= CapacityBytes.GetHashCode();
      if (Id.Length != 0) hash ^= Id.GetHashCode();
      hash ^= Attributes.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (CapacityBytes != 0L) {
        output.WriteRawTag(8);
        output.WriteInt64(CapacityBytes);
      }
      if (Id.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Id);
      }
      attributes_.WriteTo(output, _map_attributes_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (CapacityBytes != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(CapacityBytes);
      }
      if (Id.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Id);
      }
      size += attributes_.CalculateSize(_map_attributes_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Volume other) {
      if (other == null) {
        return;
      }
      if (other.CapacityBytes != 0L) {
        CapacityBytes = other.CapacityBytes;
      }
      if (other.Id.Length != 0) {
        Id = other.Id;
      }
      attributes_.Add(other.attributes_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            CapacityBytes = input.ReadInt64();
            break;
          }
          case 18: {
            Id = input.ReadString();
            break;
          }
          case 26: {
            attributes_.AddEntriesFrom(input, _map_attributes_codec);
            break;
          }
        }
      }
    }

  }

  public sealed partial class DeleteVolumeRequest : pb::IMessage<DeleteVolumeRequest> {
    private static readonly pb::MessageParser<DeleteVolumeRequest> _parser = new pb::MessageParser<DeleteVolumeRequest>(() => new DeleteVolumeRequest());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<DeleteVolumeRequest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Csi.V0.CsiReflection.Descriptor.MessageTypes[12]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DeleteVolumeRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DeleteVolumeRequest(DeleteVolumeRequest other) : this() {
      volumeId_ = other.volumeId_;
      controllerDeleteSecrets_ = other.controllerDeleteSecrets_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DeleteVolumeRequest Clone() {
      return new DeleteVolumeRequest(this);
    }

    /// <summary>Field number for the "volume_id" field.</summary>
    public const int VolumeIdFieldNumber = 1;
    private string volumeId_ = "";
    /// <summary>
    /// The ID of the volume to be deprovisioned.
    /// This field is REQUIRED.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string VolumeId {
      get { return volumeId_; }
      set {
        volumeId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "controller_delete_secrets" field.</summary>
    public const int ControllerDeleteSecretsFieldNumber = 2;
    private static readonly pbc::MapField<string, string>.Codec _map_controllerDeleteSecrets_codec
        = new pbc::MapField<string, string>.Codec(pb::FieldCodec.ForString(10), pb::FieldCodec.ForString(18), 18);
    private readonly pbc::MapField<string, string> controllerDeleteSecrets_ = new pbc::MapField<string, string>();
    /// <summary>
    /// Secrets required by plugin to complete volume deletion request.
    /// A secret is a string to string map where the key identifies the
    /// name of the secret (e.g. "username" or "password"), and the value
    /// contains the secret data (e.g. "bob" or "abc123").
    /// Each key MUST consist of alphanumeric characters, '-', '_' or '.'.
    /// Each value MUST contain a valid string. An SP MAY choose to accept
    /// binary (non-string) data by using a binary-to-text encoding scheme,
    /// like base64.
    /// An SP SHALL advertise the requirements for required secret keys and
    /// values in documentation.
    /// CO SHALL permit passing through the required secrets.
    /// A CO MAY pass the same secrets to all RPCs, therefore the keys for
    /// all unique secrets that an SP expects must be unique across all CSI
    /// operations.
    /// This information is sensitive and MUST be treated as such (not
    /// logged, etc.) by the CO.
    /// This field is OPTIONAL.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::MapField<string, string> ControllerDeleteSecrets {
      get { return controllerDeleteSecrets_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as DeleteVolumeRequest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(DeleteVolumeRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (VolumeId != other.VolumeId) return false;
      if (!ControllerDeleteSecrets.Equals(other.ControllerDeleteSecrets)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (VolumeId.Length != 0) hash ^= VolumeId.GetHashCode();
      hash ^= ControllerDeleteSecrets.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (VolumeId.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(VolumeId);
      }
      controllerDeleteSecrets_.WriteTo(output, _map_controllerDeleteSecrets_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (VolumeId.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(VolumeId);
      }
      size += controllerDeleteSecrets_.CalculateSize(_map_controllerDeleteSecrets_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(DeleteVolumeRequest other) {
      if (other == null) {
        return;
      }
      if (other.VolumeId.Length != 0) {
        VolumeId = other.VolumeId;
      }
      controllerDeleteSecrets_.Add(other.controllerDeleteSecrets_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            VolumeId = input.ReadString();
            break;
          }
          case 18: {
            controllerDeleteSecrets_.AddEntriesFrom(input, _map_controllerDeleteSecrets_codec);
            break;
          }
        }
      }
    }

  }

  public sealed partial class DeleteVolumeResponse : pb::IMessage<DeleteVolumeResponse> {
    private static readonly pb::MessageParser<DeleteVolumeResponse> _parser = new pb::MessageParser<DeleteVolumeResponse>(() => new DeleteVolumeResponse());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<DeleteVolumeResponse> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Csi.V0.CsiReflection.Descriptor.MessageTypes[13]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DeleteVolumeResponse() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DeleteVolumeResponse(DeleteVolumeResponse other) : this() {
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DeleteVolumeResponse Clone() {
      return new DeleteVolumeResponse(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as DeleteVolumeResponse);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(DeleteVolumeResponse other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(DeleteVolumeResponse other) {
      if (other == null) {
        return;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
        }
      }
    }

  }

  public sealed partial class ControllerPublishVolumeRequest : pb::IMessage<ControllerPublishVolumeRequest> {
    private static readonly pb::MessageParser<ControllerPublishVolumeRequest> _parser = new pb::MessageParser<ControllerPublishVolumeRequest>(() => new ControllerPublishVolumeRequest());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ControllerPublishVolumeRequest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Csi.V0.CsiReflection.Descriptor.MessageTypes[14]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ControllerPublishVolumeRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ControllerPublishVolumeRequest(ControllerPublishVolumeRequest other) : this() {
      volumeId_ = other.volumeId_;
      nodeId_ = other.nodeId_;
      VolumeCapability = other.volumeCapability_ != null ? other.VolumeCapability.Clone() : null;
      readonly_ = other.readonly_;
      controllerPublishSecrets_ = other.controllerPublishSecrets_.Clone();
      volumeAttributes_ = other.volumeAttributes_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ControllerPublishVolumeRequest Clone() {
      return new ControllerPublishVolumeRequest(this);
    }

    /// <summary>Field number for the "volume_id" field.</summary>
    public const int VolumeIdFieldNumber = 1;
    private string volumeId_ = "";
    /// <summary>
    /// The ID of the volume to be used on a node.
    /// This field is REQUIRED.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string VolumeId {
      get { return volumeId_; }
      set {
        volumeId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "node_id" field.</summary>
    public const int NodeIdFieldNumber = 2;
    private string nodeId_ = "";
    /// <summary>
    /// The ID of the node. This field is REQUIRED. The CO SHALL set this
    /// field to match the node ID returned by `NodeGetId`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string NodeId {
      get { return nodeId_; }
      set {
        nodeId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "volume_capability" field.</summary>
    public const int VolumeCapabilityFieldNumber = 3;
    private global::Csi.V0.VolumeCapability volumeCapability_;
    /// <summary>
    /// The capability of the volume the CO expects the volume to have.
    /// This is a REQUIRED field.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Csi.V0.VolumeCapability VolumeCapability {
      get { return volumeCapability_; }
      set {
        volumeCapability_ = value;
      }
    }

    /// <summary>Field number for the "readonly" field.</summary>
    public const int ReadonlyFieldNumber = 4;
    private bool readonly_;
    /// <summary>
    /// Whether to publish the volume in readonly mode. This field is
    /// REQUIRED.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Readonly {
      get { return readonly_; }
      set {
        readonly_ = value;
      }
    }

    /// <summary>Field number for the "controller_publish_secrets" field.</summary>
    public const int ControllerPublishSecretsFieldNumber = 5;
    private static readonly pbc::MapField<string, string>.Codec _map_controllerPublishSecrets_codec
        = new pbc::MapField<string, string>.Codec(pb::FieldCodec.ForString(10), pb::FieldCodec.ForString(18), 42);
    private readonly pbc::MapField<string, string> controllerPublishSecrets_ = new pbc::MapField<string, string>();
    /// <summary>
    /// Secrets required by plugin to complete controller publish volume
    /// request.
    /// A secret is a string to string map where the key identifies the
    /// name of the secret (e.g. "username" or "password"), and the value
    /// contains the secret data (e.g. "bob" or "abc123").
    /// Each key MUST consist of alphanumeric characters, '-', '_' or '.'.
    /// Each value MUST contain a valid string. An SP MAY choose to accept
    /// binary (non-string) data by using a binary-to-text encoding scheme,
    /// like base64.
    /// An SP SHALL advertise the requirements for required secret keys and
    /// values in documentation.
    /// CO SHALL permit passing through the required secrets.
    /// A CO MAY pass the same secrets to all RPCs, therefore the keys for
    /// all unique secrets that an SP expects must be unique across all CSI
    /// operations.
    /// This information is sensitive and MUST be treated as such (not
    /// logged, etc.) by the CO.
    /// This field is OPTIONAL.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::MapField<string, string> ControllerPublishSecrets {
      get { return controllerPublishSecrets_; }
    }

    /// <summary>Field number for the "volume_attributes" field.</summary>
    public const int VolumeAttributesFieldNumber = 6;
    private static readonly pbc::MapField<string, string>.Codec _map_volumeAttributes_codec
        = new pbc::MapField<string, string>.Codec(pb::FieldCodec.ForString(10), pb::FieldCodec.ForString(18), 50);
    private readonly pbc::MapField<string, string> volumeAttributes_ = new pbc::MapField<string, string>();
    /// <summary>
    /// Attributes of the volume to be used on a node. This field is
    /// OPTIONAL and MUST match the attributes of the Volume identified
    /// by `volume_id`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::MapField<string, string> VolumeAttributes {
      get { return volumeAttributes_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ControllerPublishVolumeRequest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ControllerPublishVolumeRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (VolumeId != other.VolumeId) return false;
      if (NodeId != other.NodeId) return false;
      if (!object.Equals(VolumeCapability, other.VolumeCapability)) return false;
      if (Readonly != other.Readonly) return false;
      if (!ControllerPublishSecrets.Equals(other.ControllerPublishSecrets)) return false;
      if (!VolumeAttributes.Equals(other.VolumeAttributes)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (VolumeId.Length != 0) hash ^= VolumeId.GetHashCode();
      if (NodeId.Length != 0) hash ^= NodeId.GetHashCode();
      if (volumeCapability_ != null) hash ^= VolumeCapability.GetHashCode();
      if (Readonly != false) hash ^= Readonly.GetHashCode();
      hash ^= ControllerPublishSecrets.GetHashCode();
      hash ^= VolumeAttributes.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (VolumeId.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(VolumeId);
      }
      if (NodeId.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(NodeId);
      }
      if (volumeCapability_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(VolumeCapability);
      }
      if (Readonly != false) {
        output.WriteRawTag(32);
        output.WriteBool(Readonly);
      }
      controllerPublishSecrets_.WriteTo(output, _map_controllerPublishSecrets_codec);
      volumeAttributes_.WriteTo(output, _map_volumeAttributes_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (VolumeId.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(VolumeId);
      }
      if (NodeId.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(NodeId);
      }
      if (volumeCapability_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(VolumeCapability);
      }
      if (Readonly != false) {
        size += 1 + 1;
      }
      size += controllerPublishSecrets_.CalculateSize(_map_controllerPublishSecrets_codec);
      size += volumeAttributes_.CalculateSize(_map_volumeAttributes_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ControllerPublishVolumeRequest other) {
      if (other == null) {
        return;
      }
      if (other.VolumeId.Length != 0) {
        VolumeId = other.VolumeId;
      }
      if (other.NodeId.Length != 0) {
        NodeId = other.NodeId;
      }
      if (other.volumeCapability_ != null) {
        if (volumeCapability_ == null) {
          volumeCapability_ = new global::Csi.V0.VolumeCapability();
        }
        VolumeCapability.MergeFrom(other.VolumeCapability);
      }
      if (other.Readonly != false) {
        Readonly = other.Readonly;
      }
      controllerPublishSecrets_.Add(other.controllerPublishSecrets_);
      volumeAttributes_.Add(other.volumeAttributes_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            VolumeId = input.ReadString();
            break;
          }
          case 18: {
            NodeId = input.ReadString();
            break;
          }
          case 26: {
            if (volumeCapability_ == null) {
              volumeCapability_ = new global::Csi.V0.VolumeCapability();
            }
            input.ReadMessage(volumeCapability_);
            break;
          }
          case 32: {
            Readonly = input.ReadBool();
            break;
          }
          case 42: {
            controllerPublishSecrets_.AddEntriesFrom(input, _map_controllerPublishSecrets_codec);
            break;
          }
          case 50: {
            volumeAttributes_.AddEntriesFrom(input, _map_volumeAttributes_codec);
            break;
          }
        }
      }
    }

  }

  public sealed partial class ControllerPublishVolumeResponse : pb::IMessage<ControllerPublishVolumeResponse> {
    private static readonly pb::MessageParser<ControllerPublishVolumeResponse> _parser = new pb::MessageParser<ControllerPublishVolumeResponse>(() => new ControllerPublishVolumeResponse());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ControllerPublishVolumeResponse> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Csi.V0.CsiReflection.Descriptor.MessageTypes[15]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ControllerPublishVolumeResponse() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ControllerPublishVolumeResponse(ControllerPublishVolumeResponse other) : this() {
      publishInfo_ = other.publishInfo_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ControllerPublishVolumeResponse Clone() {
      return new ControllerPublishVolumeResponse(this);
    }

    /// <summary>Field number for the "publish_info" field.</summary>
    public const int PublishInfoFieldNumber = 1;
    private static readonly pbc::MapField<string, string>.Codec _map_publishInfo_codec
        = new pbc::MapField<string, string>.Codec(pb::FieldCodec.ForString(10), pb::FieldCodec.ForString(18), 10);
    private readonly pbc::MapField<string, string> publishInfo_ = new pbc::MapField<string, string>();
    /// <summary>
    /// The SP specific information that will be passed to the Plugin in
    /// the subsequent `NodeStageVolume` or `NodePublishVolume` calls
    /// for the given volume.
    /// This information is opaque to the CO. This field is OPTIONAL.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::MapField<string, string> PublishInfo {
      get { return publishInfo_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ControllerPublishVolumeResponse);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ControllerPublishVolumeResponse other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!PublishInfo.Equals(other.PublishInfo)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= PublishInfo.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      publishInfo_.WriteTo(output, _map_publishInfo_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += publishInfo_.CalculateSize(_map_publishInfo_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ControllerPublishVolumeResponse other) {
      if (other == null) {
        return;
      }
      publishInfo_.Add(other.publishInfo_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            publishInfo_.AddEntriesFrom(input, _map_publishInfo_codec);
            break;
          }
        }
      }
    }

  }

  public sealed partial class ControllerUnpublishVolumeRequest : pb::IMessage<ControllerUnpublishVolumeRequest> {
    private static readonly pb::MessageParser<ControllerUnpublishVolumeRequest> _parser = new pb::MessageParser<ControllerUnpublishVolumeRequest>(() => new ControllerUnpublishVolumeRequest());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ControllerUnpublishVolumeRequest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Csi.V0.CsiReflection.Descriptor.MessageTypes[16]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ControllerUnpublishVolumeRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ControllerUnpublishVolumeRequest(ControllerUnpublishVolumeRequest other) : this() {
      volumeId_ = other.volumeId_;
      nodeId_ = other.nodeId_;
      controllerUnpublishSecrets_ = other.controllerUnpublishSecrets_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ControllerUnpublishVolumeRequest Clone() {
      return new ControllerUnpublishVolumeRequest(this);
    }

    /// <summary>Field number for the "volume_id" field.</summary>
    public const int VolumeIdFieldNumber = 1;
    private string volumeId_ = "";
    /// <summary>
    /// The ID of the volume. This field is REQUIRED.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string VolumeId {
      get { return volumeId_; }
      set {
        volumeId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "node_id" field.</summary>
    public const int NodeIdFieldNumber = 2;
    private string nodeId_ = "";
    /// <summary>
    /// The ID of the node. This field is OPTIONAL. The CO SHOULD set this
    /// field to match the node ID returned by `NodeGetId` or leave it
    /// unset. If the value is set, the SP MUST unpublish the volume from
    /// the specified node. If the value is unset, the SP MUST unpublish
    /// the volume from all nodes it is published to.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string NodeId {
      get { return nodeId_; }
      set {
        nodeId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "controller_unpublish_secrets" field.</summary>
    public const int ControllerUnpublishSecretsFieldNumber = 3;
    private static readonly pbc::MapField<string, string>.Codec _map_controllerUnpublishSecrets_codec
        = new pbc::MapField<string, string>.Codec(pb::FieldCodec.ForString(10), pb::FieldCodec.ForString(18), 26);
    private readonly pbc::MapField<string, string> controllerUnpublishSecrets_ = new pbc::MapField<string, string>();
    /// <summary>
    /// Secrets required by plugin to complete controller unpublish volume
    /// request. This SHOULD be the same secrets passed to the
    /// ControllerPublishVolume.
    /// call for the specified volume.
    /// A secret is a string to string map where the key identifies the
    /// name of the secret (e.g. "username" or "password"), and the value
    /// contains the secret data (e.g. "bob" or "abc123").
    /// Each key MUST consist of alphanumeric characters, '-', '_' or '.'.
    /// Each value MUST contain a valid string. An SP MAY choose to accept
    /// binary (non-string) data by using a binary-to-text encoding scheme,
    /// like base64.
    /// An SP SHALL advertise the requirements for required secret keys and
    /// values in documentation.
    /// CO SHALL permit passing through the required secrets.
    /// A CO MAY pass the same secrets to all RPCs, therefore the keys for
    /// all unique secrets that an SP expects must be unique across all CSI
    /// operations.
    /// This information is sensitive and MUST be treated as such (not
    /// logged, etc.) by the CO.
    /// This field is OPTIONAL.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::MapField<string, string> ControllerUnpublishSecrets {
      get { return controllerUnpublishSecrets_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ControllerUnpublishVolumeRequest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ControllerUnpublishVolumeRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (VolumeId != other.VolumeId) return false;
      if (NodeId != other.NodeId) return false;
      if (!ControllerUnpublishSecrets.Equals(other.ControllerUnpublishSecrets)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (VolumeId.Length != 0) hash ^= VolumeId.GetHashCode();
      if (NodeId.Length != 0) hash ^= NodeId.GetHashCode();
      hash ^= ControllerUnpublishSecrets.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (VolumeId.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(VolumeId);
      }
      if (NodeId.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(NodeId);
      }
      controllerUnpublishSecrets_.WriteTo(output, _map_controllerUnpublishSecrets_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (VolumeId.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(VolumeId);
      }
      if (NodeId.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(NodeId);
      }
      size += controllerUnpublishSecrets_.CalculateSize(_map_controllerUnpublishSecrets_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ControllerUnpublishVolumeRequest other) {
      if (other == null) {
        return;
      }
      if (other.VolumeId.Length != 0) {
        VolumeId = other.VolumeId;
      }
      if (other.NodeId.Length != 0) {
        NodeId = other.NodeId;
      }
      controllerUnpublishSecrets_.Add(other.controllerUnpublishSecrets_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            VolumeId = input.ReadString();
            break;
          }
          case 18: {
            NodeId = input.ReadString();
            break;
          }
          case 26: {
            controllerUnpublishSecrets_.AddEntriesFrom(input, _map_controllerUnpublishSecrets_codec);
            break;
          }
        }
      }
    }

  }

  public sealed partial class ControllerUnpublishVolumeResponse : pb::IMessage<ControllerUnpublishVolumeResponse> {
    private static readonly pb::MessageParser<ControllerUnpublishVolumeResponse> _parser = new pb::MessageParser<ControllerUnpublishVolumeResponse>(() => new ControllerUnpublishVolumeResponse());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ControllerUnpublishVolumeResponse> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Csi.V0.CsiReflection.Descriptor.MessageTypes[17]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ControllerUnpublishVolumeResponse() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ControllerUnpublishVolumeResponse(ControllerUnpublishVolumeResponse other) : this() {
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ControllerUnpublishVolumeResponse Clone() {
      return new ControllerUnpublishVolumeResponse(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ControllerUnpublishVolumeResponse);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ControllerUnpublishVolumeResponse other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ControllerUnpublishVolumeResponse other) {
      if (other == null) {
        return;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
        }
      }
    }

  }

  public sealed partial class ValidateVolumeCapabilitiesRequest : pb::IMessage<ValidateVolumeCapabilitiesRequest> {
    private static readonly pb::MessageParser<ValidateVolumeCapabilitiesRequest> _parser = new pb::MessageParser<ValidateVolumeCapabilitiesRequest>(() => new ValidateVolumeCapabilitiesRequest());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ValidateVolumeCapabilitiesRequest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Csi.V0.CsiReflection.Descriptor.MessageTypes[18]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ValidateVolumeCapabilitiesRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ValidateVolumeCapabilitiesRequest(ValidateVolumeCapabilitiesRequest other) : this() {
      volumeId_ = other.volumeId_;
      volumeCapabilities_ = other.volumeCapabilities_.Clone();
      volumeAttributes_ = other.volumeAttributes_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ValidateVolumeCapabilitiesRequest Clone() {
      return new ValidateVolumeCapabilitiesRequest(this);
    }

    /// <summary>Field number for the "volume_id" field.</summary>
    public const int VolumeIdFieldNumber = 1;
    private string volumeId_ = "";
    /// <summary>
    /// The ID of the volume to check. This field is REQUIRED.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string VolumeId {
      get { return volumeId_; }
      set {
        volumeId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "volume_capabilities" field.</summary>
    public const int VolumeCapabilitiesFieldNumber = 2;
    private static readonly pb::FieldCodec<global::Csi.V0.VolumeCapability> _repeated_volumeCapabilities_codec
        = pb::FieldCodec.ForMessage(18, global::Csi.V0.VolumeCapability.Parser);
    private readonly pbc::RepeatedField<global::Csi.V0.VolumeCapability> volumeCapabilities_ = new pbc::RepeatedField<global::Csi.V0.VolumeCapability>();
    /// <summary>
    /// The capabilities that the CO wants to check for the volume. This
    /// call SHALL return "supported" only if all the volume capabilities
    /// specified below are supported. This field is REQUIRED.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Csi.V0.VolumeCapability> VolumeCapabilities {
      get { return volumeCapabilities_; }
    }

    /// <summary>Field number for the "volume_attributes" field.</summary>
    public const int VolumeAttributesFieldNumber = 3;
    private static readonly pbc::MapField<string, string>.Codec _map_volumeAttributes_codec
        = new pbc::MapField<string, string>.Codec(pb::FieldCodec.ForString(10), pb::FieldCodec.ForString(18), 26);
    private readonly pbc::MapField<string, string> volumeAttributes_ = new pbc::MapField<string, string>();
    /// <summary>
    /// Attributes of the volume to check. This field is OPTIONAL and MUST
    /// match the attributes of the Volume identified by `volume_id`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::MapField<string, string> VolumeAttributes {
      get { return volumeAttributes_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ValidateVolumeCapabilitiesRequest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ValidateVolumeCapabilitiesRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (VolumeId != other.VolumeId) return false;
      if(!volumeCapabilities_.Equals(other.volumeCapabilities_)) return false;
      if (!VolumeAttributes.Equals(other.VolumeAttributes)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (VolumeId.Length != 0) hash ^= VolumeId.GetHashCode();
      hash ^= volumeCapabilities_.GetHashCode();
      hash ^= VolumeAttributes.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (VolumeId.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(VolumeId);
      }
      volumeCapabilities_.WriteTo(output, _repeated_volumeCapabilities_codec);
      volumeAttributes_.WriteTo(output, _map_volumeAttributes_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (VolumeId.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(VolumeId);
      }
      size += volumeCapabilities_.CalculateSize(_repeated_volumeCapabilities_codec);
      size += volumeAttributes_.CalculateSize(_map_volumeAttributes_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ValidateVolumeCapabilitiesRequest other) {
      if (other == null) {
        return;
      }
      if (other.VolumeId.Length != 0) {
        VolumeId = other.VolumeId;
      }
      volumeCapabilities_.Add(other.volumeCapabilities_);
      volumeAttributes_.Add(other.volumeAttributes_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            VolumeId = input.ReadString();
            break;
          }
          case 18: {
            volumeCapabilities_.AddEntriesFrom(input, _repeated_volumeCapabilities_codec);
            break;
          }
          case 26: {
            volumeAttributes_.AddEntriesFrom(input, _map_volumeAttributes_codec);
            break;
          }
        }
      }
    }

  }

  public sealed partial class ValidateVolumeCapabilitiesResponse : pb::IMessage<ValidateVolumeCapabilitiesResponse> {
    private static readonly pb::MessageParser<ValidateVolumeCapabilitiesResponse> _parser = new pb::MessageParser<ValidateVolumeCapabilitiesResponse>(() => new ValidateVolumeCapabilitiesResponse());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ValidateVolumeCapabilitiesResponse> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Csi.V0.CsiReflection.Descriptor.MessageTypes[19]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ValidateVolumeCapabilitiesResponse() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ValidateVolumeCapabilitiesResponse(ValidateVolumeCapabilitiesResponse other) : this() {
      supported_ = other.supported_;
      message_ = other.message_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ValidateVolumeCapabilitiesResponse Clone() {
      return new ValidateVolumeCapabilitiesResponse(this);
    }

    /// <summary>Field number for the "supported" field.</summary>
    public const int SupportedFieldNumber = 1;
    private bool supported_;
    /// <summary>
    /// True if the Plugin supports the specified capabilities for the
    /// given volume. This field is REQUIRED.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Supported {
      get { return supported_; }
      set {
        supported_ = value;
      }
    }

    /// <summary>Field number for the "message" field.</summary>
    public const int MessageFieldNumber = 2;
    private string message_ = "";
    /// <summary>
    /// Message to the CO if `supported` above is false. This field is
    /// OPTIONAL.
    /// An empty string is equal to an unspecified field value.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Message {
      get { return message_; }
      set {
        message_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ValidateVolumeCapabilitiesResponse);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ValidateVolumeCapabilitiesResponse other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Supported != other.Supported) return false;
      if (Message != other.Message) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Supported != false) hash ^= Supported.GetHashCode();
      if (Message.Length != 0) hash ^= Message.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Supported != false) {
        output.WriteRawTag(8);
        output.WriteBool(Supported);
      }
      if (Message.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Message);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Supported != false) {
        size += 1 + 1;
      }
      if (Message.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Message);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ValidateVolumeCapabilitiesResponse other) {
      if (other == null) {
        return;
      }
      if (other.Supported != false) {
        Supported = other.Supported;
      }
      if (other.Message.Length != 0) {
        Message = other.Message;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Supported = input.ReadBool();
            break;
          }
          case 18: {
            Message = input.ReadString();
            break;
          }
        }
      }
    }

  }

  public sealed partial class ListVolumesRequest : pb::IMessage<ListVolumesRequest> {
    private static readonly pb::MessageParser<ListVolumesRequest> _parser = new pb::MessageParser<ListVolumesRequest>(() => new ListVolumesRequest());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ListVolumesRequest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Csi.V0.CsiReflection.Descriptor.MessageTypes[20]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ListVolumesRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ListVolumesRequest(ListVolumesRequest other) : this() {
      maxEntries_ = other.maxEntries_;
      startingToken_ = other.startingToken_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ListVolumesRequest Clone() {
      return new ListVolumesRequest(this);
    }

    /// <summary>Field number for the "max_entries" field.</summary>
    public const int MaxEntriesFieldNumber = 1;
    private int maxEntries_;
    /// <summary>
    /// If specified (non-zero value), the Plugin MUST NOT return more
    /// entries than this number in the response. If the actual number of
    /// entries is more than this number, the Plugin MUST set `next_token`
    /// in the response which can be used to get the next page of entries
    /// in the subsequent `ListVolumes` call. This field is OPTIONAL. If
    /// not specified (zero value), it means there is no restriction on the
    /// number of entries that can be returned.
    /// The value of this field MUST NOT be negative. 
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int MaxEntries {
      get { return maxEntries_; }
      set {
        maxEntries_ = value;
      }
    }

    /// <summary>Field number for the "starting_token" field.</summary>
    public const int StartingTokenFieldNumber = 2;
    private string startingToken_ = "";
    /// <summary>
    /// A token to specify where to start paginating. Set this field to
    /// `next_token` returned by a previous `ListVolumes` call to get the
    /// next page of entries. This field is OPTIONAL.
    /// An empty string is equal to an unspecified field value.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string StartingToken {
      get { return startingToken_; }
      set {
        startingToken_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ListVolumesRequest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ListVolumesRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (MaxEntries != other.MaxEntries) return false;
      if (StartingToken != other.StartingToken) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (MaxEntries != 0) hash ^= MaxEntries.GetHashCode();
      if (StartingToken.Length != 0) hash ^= StartingToken.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (MaxEntries != 0) {
        output.WriteRawTag(8);
        output.WriteInt32(MaxEntries);
      }
      if (StartingToken.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(StartingToken);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (MaxEntries != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(MaxEntries);
      }
      if (StartingToken.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(StartingToken);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ListVolumesRequest other) {
      if (other == null) {
        return;
      }
      if (other.MaxEntries != 0) {
        MaxEntries = other.MaxEntries;
      }
      if (other.StartingToken.Length != 0) {
        StartingToken = other.StartingToken;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            MaxEntries = input.ReadInt32();
            break;
          }
          case 18: {
            StartingToken = input.ReadString();
            break;
          }
        }
      }
    }

  }

  public sealed partial class ListVolumesResponse : pb::IMessage<ListVolumesResponse> {
    private static readonly pb::MessageParser<ListVolumesResponse> _parser = new pb::MessageParser<ListVolumesResponse>(() => new ListVolumesResponse());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ListVolumesResponse> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Csi.V0.CsiReflection.Descriptor.MessageTypes[21]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ListVolumesResponse() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ListVolumesResponse(ListVolumesResponse other) : this() {
      entries_ = other.entries_.Clone();
      nextToken_ = other.nextToken_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ListVolumesResponse Clone() {
      return new ListVolumesResponse(this);
    }

    /// <summary>Field number for the "entries" field.</summary>
    public const int EntriesFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Csi.V0.ListVolumesResponse.Types.Entry> _repeated_entries_codec
        = pb::FieldCodec.ForMessage(10, global::Csi.V0.ListVolumesResponse.Types.Entry.Parser);
    private readonly pbc::RepeatedField<global::Csi.V0.ListVolumesResponse.Types.Entry> entries_ = new pbc::RepeatedField<global::Csi.V0.ListVolumesResponse.Types.Entry>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Csi.V0.ListVolumesResponse.Types.Entry> Entries {
      get { return entries_; }
    }

    /// <summary>Field number for the "next_token" field.</summary>
    public const int NextTokenFieldNumber = 2;
    private string nextToken_ = "";
    /// <summary>
    /// This token allows you to get the next page of entries for
    /// `ListVolumes` request. If the number of entries is larger than
    /// `max_entries`, use the `next_token` as a value for the
    /// `starting_token` field in the next `ListVolumes` request. This
    /// field is OPTIONAL.
    /// An empty string is equal to an unspecified field value.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string NextToken {
      get { return nextToken_; }
      set {
        nextToken_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ListVolumesResponse);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ListVolumesResponse other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!entries_.Equals(other.entries_)) return false;
      if (NextToken != other.NextToken) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= entries_.GetHashCode();
      if (NextToken.Length != 0) hash ^= NextToken.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      entries_.WriteTo(output, _repeated_entries_codec);
      if (NextToken.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(NextToken);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += entries_.CalculateSize(_repeated_entries_codec);
      if (NextToken.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(NextToken);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ListVolumesResponse other) {
      if (other == null) {
        return;
      }
      entries_.Add(other.entries_);
      if (other.NextToken.Length != 0) {
        NextToken = other.NextToken;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            entries_.AddEntriesFrom(input, _repeated_entries_codec);
            break;
          }
          case 18: {
            NextToken = input.ReadString();
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the ListVolumesResponse message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      public sealed partial class Entry : pb::IMessage<Entry> {
        private static readonly pb::MessageParser<Entry> _parser = new pb::MessageParser<Entry>(() => new Entry());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Entry> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Csi.V0.ListVolumesResponse.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Entry() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Entry(Entry other) : this() {
          Volume = other.volume_ != null ? other.Volume.Clone() : null;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Entry Clone() {
          return new Entry(this);
        }

        /// <summary>Field number for the "volume" field.</summary>
        public const int VolumeFieldNumber = 1;
        private global::Csi.V0.Volume volume_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Csi.V0.Volume Volume {
          get { return volume_; }
          set {
            volume_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as Entry);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Entry other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!object.Equals(Volume, other.Volume)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (volume_ != null) hash ^= Volume.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (volume_ != null) {
            output.WriteRawTag(10);
            output.WriteMessage(Volume);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (volume_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(Volume);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Entry other) {
          if (other == null) {
            return;
          }
          if (other.volume_ != null) {
            if (volume_ == null) {
              volume_ = new global::Csi.V0.Volume();
            }
            Volume.MergeFrom(other.Volume);
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                if (volume_ == null) {
                  volume_ = new global::Csi.V0.Volume();
                }
                input.ReadMessage(volume_);
                break;
              }
            }
          }
        }

      }

    }
    #endregion

  }

  public sealed partial class GetCapacityRequest : pb::IMessage<GetCapacityRequest> {
    private static readonly pb::MessageParser<GetCapacityRequest> _parser = new pb::MessageParser<GetCapacityRequest>(() => new GetCapacityRequest());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<GetCapacityRequest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Csi.V0.CsiReflection.Descriptor.MessageTypes[22]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GetCapacityRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GetCapacityRequest(GetCapacityRequest other) : this() {
      volumeCapabilities_ = other.volumeCapabilities_.Clone();
      parameters_ = other.parameters_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GetCapacityRequest Clone() {
      return new GetCapacityRequest(this);
    }

    /// <summary>Field number for the "volume_capabilities" field.</summary>
    public const int VolumeCapabilitiesFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Csi.V0.VolumeCapability> _repeated_volumeCapabilities_codec
        = pb::FieldCodec.ForMessage(10, global::Csi.V0.VolumeCapability.Parser);
    private readonly pbc::RepeatedField<global::Csi.V0.VolumeCapability> volumeCapabilities_ = new pbc::RepeatedField<global::Csi.V0.VolumeCapability>();
    /// <summary>
    /// If specified, the Plugin SHALL report the capacity of the storage
    /// that can be used to provision volumes that satisfy ALL of the
    /// specified `volume_capabilities`. These are the same
    /// `volume_capabilities` the CO will use in `CreateVolumeRequest`.
    /// This field is OPTIONAL.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Csi.V0.VolumeCapability> VolumeCapabilities {
      get { return volumeCapabilities_; }
    }

    /// <summary>Field number for the "parameters" field.</summary>
    public const int ParametersFieldNumber = 2;
    private static readonly pbc::MapField<string, string>.Codec _map_parameters_codec
        = new pbc::MapField<string, string>.Codec(pb::FieldCodec.ForString(10), pb::FieldCodec.ForString(18), 18);
    private readonly pbc::MapField<string, string> parameters_ = new pbc::MapField<string, string>();
    /// <summary>
    /// If specified, the Plugin SHALL report the capacity of the storage
    /// that can be used to provision volumes with the given Plugin
    /// specific `parameters`. These are the same `parameters` the CO will
    /// use in `CreateVolumeRequest`. This field is OPTIONAL.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::MapField<string, string> Parameters {
      get { return parameters_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as GetCapacityRequest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(GetCapacityRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!volumeCapabilities_.Equals(other.volumeCapabilities_)) return false;
      if (!Parameters.Equals(other.Parameters)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= volumeCapabilities_.GetHashCode();
      hash ^= Parameters.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      volumeCapabilities_.WriteTo(output, _repeated_volumeCapabilities_codec);
      parameters_.WriteTo(output, _map_parameters_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += volumeCapabilities_.CalculateSize(_repeated_volumeCapabilities_codec);
      size += parameters_.CalculateSize(_map_parameters_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(GetCapacityRequest other) {
      if (other == null) {
        return;
      }
      volumeCapabilities_.Add(other.volumeCapabilities_);
      parameters_.Add(other.parameters_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            volumeCapabilities_.AddEntriesFrom(input, _repeated_volumeCapabilities_codec);
            break;
          }
          case 18: {
            parameters_.AddEntriesFrom(input, _map_parameters_codec);
            break;
          }
        }
      }
    }

  }

  public sealed partial class GetCapacityResponse : pb::IMessage<GetCapacityResponse> {
    private static readonly pb::MessageParser<GetCapacityResponse> _parser = new pb::MessageParser<GetCapacityResponse>(() => new GetCapacityResponse());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<GetCapacityResponse> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Csi.V0.CsiReflection.Descriptor.MessageTypes[23]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GetCapacityResponse() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GetCapacityResponse(GetCapacityResponse other) : this() {
      availableCapacity_ = other.availableCapacity_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GetCapacityResponse Clone() {
      return new GetCapacityResponse(this);
    }

    /// <summary>Field number for the "available_capacity" field.</summary>
    public const int AvailableCapacityFieldNumber = 1;
    private long availableCapacity_;
    /// <summary>
    /// The available capacity of the storage that can be used to
    /// provision volumes. If `volume_capabilities` or `parameters` is
    /// specified in the request, the Plugin SHALL take those into
    /// consideration when calculating the available capacity of the
    /// storage. This field is REQUIRED.
    /// The value of this field MUST NOT be negative. 
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long AvailableCapacity {
      get { return availableCapacity_; }
      set {
        availableCapacity_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as GetCapacityResponse);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(GetCapacityResponse other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (AvailableCapacity != other.AvailableCapacity) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (AvailableCapacity != 0L) hash ^= AvailableCapacity.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (AvailableCapacity != 0L) {
        output.WriteRawTag(8);
        output.WriteInt64(AvailableCapacity);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (AvailableCapacity != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(AvailableCapacity);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(GetCapacityResponse other) {
      if (other == null) {
        return;
      }
      if (other.AvailableCapacity != 0L) {
        AvailableCapacity = other.AvailableCapacity;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            AvailableCapacity = input.ReadInt64();
            break;
          }
        }
      }
    }

  }

  public sealed partial class ControllerGetCapabilitiesRequest : pb::IMessage<ControllerGetCapabilitiesRequest> {
    private static readonly pb::MessageParser<ControllerGetCapabilitiesRequest> _parser = new pb::MessageParser<ControllerGetCapabilitiesRequest>(() => new ControllerGetCapabilitiesRequest());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ControllerGetCapabilitiesRequest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Csi.V0.CsiReflection.Descriptor.MessageTypes[24]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ControllerGetCapabilitiesRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ControllerGetCapabilitiesRequest(ControllerGetCapabilitiesRequest other) : this() {
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ControllerGetCapabilitiesRequest Clone() {
      return new ControllerGetCapabilitiesRequest(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ControllerGetCapabilitiesRequest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ControllerGetCapabilitiesRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ControllerGetCapabilitiesRequest other) {
      if (other == null) {
        return;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
        }
      }
    }

  }

  public sealed partial class ControllerGetCapabilitiesResponse : pb::IMessage<ControllerGetCapabilitiesResponse> {
    private static readonly pb::MessageParser<ControllerGetCapabilitiesResponse> _parser = new pb::MessageParser<ControllerGetCapabilitiesResponse>(() => new ControllerGetCapabilitiesResponse());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ControllerGetCapabilitiesResponse> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Csi.V0.CsiReflection.Descriptor.MessageTypes[25]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ControllerGetCapabilitiesResponse() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ControllerGetCapabilitiesResponse(ControllerGetCapabilitiesResponse other) : this() {
      capabilities_ = other.capabilities_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ControllerGetCapabilitiesResponse Clone() {
      return new ControllerGetCapabilitiesResponse(this);
    }

    /// <summary>Field number for the "capabilities" field.</summary>
    public const int CapabilitiesFieldNumber = 2;
    private static readonly pb::FieldCodec<global::Csi.V0.ControllerServiceCapability> _repeated_capabilities_codec
        = pb::FieldCodec.ForMessage(18, global::Csi.V0.ControllerServiceCapability.Parser);
    private readonly pbc::RepeatedField<global::Csi.V0.ControllerServiceCapability> capabilities_ = new pbc::RepeatedField<global::Csi.V0.ControllerServiceCapability>();
    /// <summary>
    /// All the capabilities that the controller service supports. This
    /// field is OPTIONAL.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Csi.V0.ControllerServiceCapability> Capabilities {
      get { return capabilities_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ControllerGetCapabilitiesResponse);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ControllerGetCapabilitiesResponse other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!capabilities_.Equals(other.capabilities_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= capabilities_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      capabilities_.WriteTo(output, _repeated_capabilities_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += capabilities_.CalculateSize(_repeated_capabilities_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ControllerGetCapabilitiesResponse other) {
      if (other == null) {
        return;
      }
      capabilities_.Add(other.capabilities_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 18: {
            capabilities_.AddEntriesFrom(input, _repeated_capabilities_codec);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Specifies a capability of the controller service.
  /// </summary>
  public sealed partial class ControllerServiceCapability : pb::IMessage<ControllerServiceCapability> {
    private static readonly pb::MessageParser<ControllerServiceCapability> _parser = new pb::MessageParser<ControllerServiceCapability>(() => new ControllerServiceCapability());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ControllerServiceCapability> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Csi.V0.CsiReflection.Descriptor.MessageTypes[26]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ControllerServiceCapability() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ControllerServiceCapability(ControllerServiceCapability other) : this() {
      switch (other.TypeCase) {
        case TypeOneofCase.Rpc:
          Rpc = other.Rpc.Clone();
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ControllerServiceCapability Clone() {
      return new ControllerServiceCapability(this);
    }

    /// <summary>Field number for the "rpc" field.</summary>
    public const int RpcFieldNumber = 1;
    /// <summary>
    /// RPC that the controller supports.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Csi.V0.ControllerServiceCapability.Types.RPC Rpc {
      get { return typeCase_ == TypeOneofCase.Rpc ? (global::Csi.V0.ControllerServiceCapability.Types.RPC) type_ : null; }
      set {
        type_ = value;
        typeCase_ = value == null ? TypeOneofCase.None : TypeOneofCase.Rpc;
      }
    }

    private object type_;
    /// <summary>Enum of possible cases for the "type" oneof.</summary>
    public enum TypeOneofCase {
      None = 0,
      Rpc = 1,
    }
    private TypeOneofCase typeCase_ = TypeOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TypeOneofCase TypeCase {
      get { return typeCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearType() {
      typeCase_ = TypeOneofCase.None;
      type_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ControllerServiceCapability);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ControllerServiceCapability other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Rpc, other.Rpc)) return false;
      if (TypeCase != other.TypeCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (typeCase_ == TypeOneofCase.Rpc) hash ^= Rpc.GetHashCode();
      hash ^= (int) typeCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (typeCase_ == TypeOneofCase.Rpc) {
        output.WriteRawTag(10);
        output.WriteMessage(Rpc);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (typeCase_ == TypeOneofCase.Rpc) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Rpc);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ControllerServiceCapability other) {
      if (other == null) {
        return;
      }
      switch (other.TypeCase) {
        case TypeOneofCase.Rpc:
          if (Rpc == null) {
            Rpc = new global::Csi.V0.ControllerServiceCapability.Types.RPC();
          }
          Rpc.MergeFrom(other.Rpc);
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            global::Csi.V0.ControllerServiceCapability.Types.RPC subBuilder = new global::Csi.V0.ControllerServiceCapability.Types.RPC();
            if (typeCase_ == TypeOneofCase.Rpc) {
              subBuilder.MergeFrom(Rpc);
            }
            input.ReadMessage(subBuilder);
            Rpc = subBuilder;
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the ControllerServiceCapability message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      public sealed partial class RPC : pb::IMessage<RPC> {
        private static readonly pb::MessageParser<RPC> _parser = new pb::MessageParser<RPC>(() => new RPC());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<RPC> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Csi.V0.ControllerServiceCapability.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public RPC() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public RPC(RPC other) : this() {
          type_ = other.type_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public RPC Clone() {
          return new RPC(this);
        }

        /// <summary>Field number for the "type" field.</summary>
        public const int TypeFieldNumber = 1;
        private global::Csi.V0.ControllerServiceCapability.Types.RPC.Types.Type type_ = 0;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Csi.V0.ControllerServiceCapability.Types.RPC.Types.Type Type {
          get { return type_; }
          set {
            type_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as RPC);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(RPC other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Type != other.Type) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (Type != 0) hash ^= Type.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (Type != 0) {
            output.WriteRawTag(8);
            output.WriteEnum((int) Type);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (Type != 0) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Type);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(RPC other) {
          if (other == null) {
            return;
          }
          if (other.Type != 0) {
            Type = other.Type;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                type_ = (global::Csi.V0.ControllerServiceCapability.Types.RPC.Types.Type) input.ReadEnum();
                break;
              }
            }
          }
        }

        #region Nested types
        /// <summary>Container for nested types declared in the RPC message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static partial class Types {
          public enum Type {
            [pbr::OriginalName("UNKNOWN")] Unknown = 0,
            [pbr::OriginalName("CREATE_DELETE_VOLUME")] CreateDeleteVolume = 1,
            [pbr::OriginalName("PUBLISH_UNPUBLISH_VOLUME")] PublishUnpublishVolume = 2,
            [pbr::OriginalName("LIST_VOLUMES")] ListVolumes = 3,
            [pbr::OriginalName("GET_CAPACITY")] GetCapacity = 4,
          }

        }
        #endregion

      }

    }
    #endregion

  }

  public sealed partial class NodeStageVolumeRequest : pb::IMessage<NodeStageVolumeRequest> {
    private static readonly pb::MessageParser<NodeStageVolumeRequest> _parser = new pb::MessageParser<NodeStageVolumeRequest>(() => new NodeStageVolumeRequest());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<NodeStageVolumeRequest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Csi.V0.CsiReflection.Descriptor.MessageTypes[27]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public NodeStageVolumeRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public NodeStageVolumeRequest(NodeStageVolumeRequest other) : this() {
      volumeId_ = other.volumeId_;
      publishInfo_ = other.publishInfo_.Clone();
      stagingTargetPath_ = other.stagingTargetPath_;
      VolumeCapability = other.volumeCapability_ != null ? other.VolumeCapability.Clone() : null;
      nodeStageSecrets_ = other.nodeStageSecrets_.Clone();
      volumeAttributes_ = other.volumeAttributes_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public NodeStageVolumeRequest Clone() {
      return new NodeStageVolumeRequest(this);
    }

    /// <summary>Field number for the "volume_id" field.</summary>
    public const int VolumeIdFieldNumber = 1;
    private string volumeId_ = "";
    /// <summary>
    /// The ID of the volume to publish. This field is REQUIRED.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string VolumeId {
      get { return volumeId_; }
      set {
        volumeId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "publish_info" field.</summary>
    public const int PublishInfoFieldNumber = 2;
    private static readonly pbc::MapField<string, string>.Codec _map_publishInfo_codec
        = new pbc::MapField<string, string>.Codec(pb::FieldCodec.ForString(10), pb::FieldCodec.ForString(18), 18);
    private readonly pbc::MapField<string, string> publishInfo_ = new pbc::MapField<string, string>();
    /// <summary>
    /// The CO SHALL set this field to the value returned by
    /// `ControllerPublishVolume` if the corresponding Controller Plugin
    /// has `PUBLISH_UNPUBLISH_VOLUME` controller capability, and SHALL be
    /// left unset if the corresponding Controller Plugin does not have
    /// this capability. This is an OPTIONAL field.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::MapField<string, string> PublishInfo {
      get { return publishInfo_; }
    }

    /// <summary>Field number for the "staging_target_path" field.</summary>
    public const int StagingTargetPathFieldNumber = 3;
    private string stagingTargetPath_ = "";
    /// <summary>
    /// The path to which the volume will be published. It MUST be an
    /// absolute path in the root filesystem of the process serving this
    /// request. The CO SHALL ensure that there is only one 
    /// staging_target_path per volume.
    /// This is a REQUIRED field.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string StagingTargetPath {
      get { return stagingTargetPath_; }
      set {
        stagingTargetPath_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "volume_capability" field.</summary>
    public const int VolumeCapabilityFieldNumber = 4;
    private global::Csi.V0.VolumeCapability volumeCapability_;
    /// <summary>
    /// The capability of the volume the CO expects the volume to have.
    /// This is a REQUIRED field.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Csi.V0.VolumeCapability VolumeCapability {
      get { return volumeCapability_; }
      set {
        volumeCapability_ = value;
      }
    }

    /// <summary>Field number for the "node_stage_secrets" field.</summary>
    public const int NodeStageSecretsFieldNumber = 5;
    private static readonly pbc::MapField<string, string>.Codec _map_nodeStageSecrets_codec
        = new pbc::MapField<string, string>.Codec(pb::FieldCodec.ForString(10), pb::FieldCodec.ForString(18), 42);
    private readonly pbc::MapField<string, string> nodeStageSecrets_ = new pbc::MapField<string, string>();
    /// <summary>
    /// Secrets required by plugin to complete node stage volume request.
    /// A secret is a string to string map where the key identifies the
    /// name of the secret (e.g. "username" or "password"), and the value
    /// contains the secret data (e.g. "bob" or "abc123").
    /// Each key MUST consist of alphanumeric characters, '-', '_' or '.'.
    /// Each value MUST contain a valid string. An SP MAY choose to accept
    /// binary (non-string) data by using a binary-to-text encoding scheme,
    /// like base64.
    /// An SP SHALL advertise the requirements for required secret keys and
    /// values in documentation.
    /// CO SHALL permit passing through the required secrets.
    /// A CO MAY pass the same secrets to all RPCs, therefore the keys for
    /// all unique secrets that an SP expects must be unique across all CSI
    /// operations.
    /// This information is sensitive and MUST be treated as such (not
    /// logged, etc.) by the CO.
    /// This field is OPTIONAL.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::MapField<string, string> NodeStageSecrets {
      get { return nodeStageSecrets_; }
    }

    /// <summary>Field number for the "volume_attributes" field.</summary>
    public const int VolumeAttributesFieldNumber = 6;
    private static readonly pbc::MapField<string, string>.Codec _map_volumeAttributes_codec
        = new pbc::MapField<string, string>.Codec(pb::FieldCodec.ForString(10), pb::FieldCodec.ForString(18), 50);
    private readonly pbc::MapField<string, string> volumeAttributes_ = new pbc::MapField<string, string>();
    /// <summary>
    /// Attributes of the volume to publish. This field is OPTIONAL and
    /// MUST match the attributes of the VolumeInfo identified by
    /// `volume_id`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::MapField<string, string> VolumeAttributes {
      get { return volumeAttributes_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as NodeStageVolumeRequest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(NodeStageVolumeRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (VolumeId != other.VolumeId) return false;
      if (!PublishInfo.Equals(other.PublishInfo)) return false;
      if (StagingTargetPath != other.StagingTargetPath) return false;
      if (!object.Equals(VolumeCapability, other.VolumeCapability)) return false;
      if (!NodeStageSecrets.Equals(other.NodeStageSecrets)) return false;
      if (!VolumeAttributes.Equals(other.VolumeAttributes)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (VolumeId.Length != 0) hash ^= VolumeId.GetHashCode();
      hash ^= PublishInfo.GetHashCode();
      if (StagingTargetPath.Length != 0) hash ^= StagingTargetPath.GetHashCode();
      if (volumeCapability_ != null) hash ^= VolumeCapability.GetHashCode();
      hash ^= NodeStageSecrets.GetHashCode();
      hash ^= VolumeAttributes.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (VolumeId.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(VolumeId);
      }
      publishInfo_.WriteTo(output, _map_publishInfo_codec);
      if (StagingTargetPath.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(StagingTargetPath);
      }
      if (volumeCapability_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(VolumeCapability);
      }
      nodeStageSecrets_.WriteTo(output, _map_nodeStageSecrets_codec);
      volumeAttributes_.WriteTo(output, _map_volumeAttributes_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (VolumeId.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(VolumeId);
      }
      size += publishInfo_.CalculateSize(_map_publishInfo_codec);
      if (StagingTargetPath.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(StagingTargetPath);
      }
      if (volumeCapability_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(VolumeCapability);
      }
      size += nodeStageSecrets_.CalculateSize(_map_nodeStageSecrets_codec);
      size += volumeAttributes_.CalculateSize(_map_volumeAttributes_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(NodeStageVolumeRequest other) {
      if (other == null) {
        return;
      }
      if (other.VolumeId.Length != 0) {
        VolumeId = other.VolumeId;
      }
      publishInfo_.Add(other.publishInfo_);
      if (other.StagingTargetPath.Length != 0) {
        StagingTargetPath = other.StagingTargetPath;
      }
      if (other.volumeCapability_ != null) {
        if (volumeCapability_ == null) {
          volumeCapability_ = new global::Csi.V0.VolumeCapability();
        }
        VolumeCapability.MergeFrom(other.VolumeCapability);
      }
      nodeStageSecrets_.Add(other.nodeStageSecrets_);
      volumeAttributes_.Add(other.volumeAttributes_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            VolumeId = input.ReadString();
            break;
          }
          case 18: {
            publishInfo_.AddEntriesFrom(input, _map_publishInfo_codec);
            break;
          }
          case 26: {
            StagingTargetPath = input.ReadString();
            break;
          }
          case 34: {
            if (volumeCapability_ == null) {
              volumeCapability_ = new global::Csi.V0.VolumeCapability();
            }
            input.ReadMessage(volumeCapability_);
            break;
          }
          case 42: {
            nodeStageSecrets_.AddEntriesFrom(input, _map_nodeStageSecrets_codec);
            break;
          }
          case 50: {
            volumeAttributes_.AddEntriesFrom(input, _map_volumeAttributes_codec);
            break;
          }
        }
      }
    }

  }

  public sealed partial class NodeStageVolumeResponse : pb::IMessage<NodeStageVolumeResponse> {
    private static readonly pb::MessageParser<NodeStageVolumeResponse> _parser = new pb::MessageParser<NodeStageVolumeResponse>(() => new NodeStageVolumeResponse());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<NodeStageVolumeResponse> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Csi.V0.CsiReflection.Descriptor.MessageTypes[28]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public NodeStageVolumeResponse() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public NodeStageVolumeResponse(NodeStageVolumeResponse other) : this() {
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public NodeStageVolumeResponse Clone() {
      return new NodeStageVolumeResponse(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as NodeStageVolumeResponse);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(NodeStageVolumeResponse other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(NodeStageVolumeResponse other) {
      if (other == null) {
        return;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
        }
      }
    }

  }

  public sealed partial class NodeUnstageVolumeRequest : pb::IMessage<NodeUnstageVolumeRequest> {
    private static readonly pb::MessageParser<NodeUnstageVolumeRequest> _parser = new pb::MessageParser<NodeUnstageVolumeRequest>(() => new NodeUnstageVolumeRequest());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<NodeUnstageVolumeRequest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Csi.V0.CsiReflection.Descriptor.MessageTypes[29]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public NodeUnstageVolumeRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public NodeUnstageVolumeRequest(NodeUnstageVolumeRequest other) : this() {
      volumeId_ = other.volumeId_;
      stagingTargetPath_ = other.stagingTargetPath_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public NodeUnstageVolumeRequest Clone() {
      return new NodeUnstageVolumeRequest(this);
    }

    /// <summary>Field number for the "volume_id" field.</summary>
    public const int VolumeIdFieldNumber = 1;
    private string volumeId_ = "";
    /// <summary>
    /// The ID of the volume. This field is REQUIRED.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string VolumeId {
      get { return volumeId_; }
      set {
        volumeId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "staging_target_path" field.</summary>
    public const int StagingTargetPathFieldNumber = 2;
    private string stagingTargetPath_ = "";
    /// <summary>
    /// The path at which the volume was published. It MUST be an absolute
    /// path in the root filesystem of the process serving this request.
    /// This is a REQUIRED field.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string StagingTargetPath {
      get { return stagingTargetPath_; }
      set {
        stagingTargetPath_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as NodeUnstageVolumeRequest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(NodeUnstageVolumeRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (VolumeId != other.VolumeId) return false;
      if (StagingTargetPath != other.StagingTargetPath) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (VolumeId.Length != 0) hash ^= VolumeId.GetHashCode();
      if (StagingTargetPath.Length != 0) hash ^= StagingTargetPath.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (VolumeId.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(VolumeId);
      }
      if (StagingTargetPath.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(StagingTargetPath);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (VolumeId.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(VolumeId);
      }
      if (StagingTargetPath.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(StagingTargetPath);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(NodeUnstageVolumeRequest other) {
      if (other == null) {
        return;
      }
      if (other.VolumeId.Length != 0) {
        VolumeId = other.VolumeId;
      }
      if (other.StagingTargetPath.Length != 0) {
        StagingTargetPath = other.StagingTargetPath;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            VolumeId = input.ReadString();
            break;
          }
          case 18: {
            StagingTargetPath = input.ReadString();
            break;
          }
        }
      }
    }

  }

  public sealed partial class NodeUnstageVolumeResponse : pb::IMessage<NodeUnstageVolumeResponse> {
    private static readonly pb::MessageParser<NodeUnstageVolumeResponse> _parser = new pb::MessageParser<NodeUnstageVolumeResponse>(() => new NodeUnstageVolumeResponse());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<NodeUnstageVolumeResponse> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Csi.V0.CsiReflection.Descriptor.MessageTypes[30]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public NodeUnstageVolumeResponse() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public NodeUnstageVolumeResponse(NodeUnstageVolumeResponse other) : this() {
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public NodeUnstageVolumeResponse Clone() {
      return new NodeUnstageVolumeResponse(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as NodeUnstageVolumeResponse);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(NodeUnstageVolumeResponse other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(NodeUnstageVolumeResponse other) {
      if (other == null) {
        return;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
        }
      }
    }

  }

  public sealed partial class NodePublishVolumeRequest : pb::IMessage<NodePublishVolumeRequest> {
    private static readonly pb::MessageParser<NodePublishVolumeRequest> _parser = new pb::MessageParser<NodePublishVolumeRequest>(() => new NodePublishVolumeRequest());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<NodePublishVolumeRequest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Csi.V0.CsiReflection.Descriptor.MessageTypes[31]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public NodePublishVolumeRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public NodePublishVolumeRequest(NodePublishVolumeRequest other) : this() {
      volumeId_ = other.volumeId_;
      publishInfo_ = other.publishInfo_.Clone();
      stagingTargetPath_ = other.stagingTargetPath_;
      targetPath_ = other.targetPath_;
      VolumeCapability = other.volumeCapability_ != null ? other.VolumeCapability.Clone() : null;
      readonly_ = other.readonly_;
      nodePublishSecrets_ = other.nodePublishSecrets_.Clone();
      volumeAttributes_ = other.volumeAttributes_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public NodePublishVolumeRequest Clone() {
      return new NodePublishVolumeRequest(this);
    }

    /// <summary>Field number for the "volume_id" field.</summary>
    public const int VolumeIdFieldNumber = 1;
    private string volumeId_ = "";
    /// <summary>
    /// The ID of the volume to publish. This field is REQUIRED.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string VolumeId {
      get { return volumeId_; }
      set {
        volumeId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "publish_info" field.</summary>
    public const int PublishInfoFieldNumber = 2;
    private static readonly pbc::MapField<string, string>.Codec _map_publishInfo_codec
        = new pbc::MapField<string, string>.Codec(pb::FieldCodec.ForString(10), pb::FieldCodec.ForString(18), 18);
    private readonly pbc::MapField<string, string> publishInfo_ = new pbc::MapField<string, string>();
    /// <summary>
    /// The CO SHALL set this field to the value returned by
    /// `ControllerPublishVolume` if the corresponding Controller Plugin
    /// has `PUBLISH_UNPUBLISH_VOLUME` controller capability, and SHALL be
    /// left unset if the corresponding Controller Plugin does not have
    /// this capability. This is an OPTIONAL field.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::MapField<string, string> PublishInfo {
      get { return publishInfo_; }
    }

    /// <summary>Field number for the "staging_target_path" field.</summary>
    public const int StagingTargetPathFieldNumber = 3;
    private string stagingTargetPath_ = "";
    /// <summary>
    /// The path to which the device was mounted by `NodeStageVolume`.
    /// It MUST be an absolute path in the root filesystem of the process
    /// serving this request.
    /// It MUST be set if the Node Plugin implements the 
    /// `STAGE_UNSTAGE_VOLUME` node capability.
    /// This is an OPTIONAL field.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string StagingTargetPath {
      get { return stagingTargetPath_; }
      set {
        stagingTargetPath_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "target_path" field.</summary>
    public const int TargetPathFieldNumber = 4;
    private string targetPath_ = "";
    /// <summary>
    /// The path to which the volume will be published. It MUST be an
    /// absolute path in the root filesystem of the process serving this
    /// request. The CO SHALL ensure uniqueness of target_path per volume.
    /// The CO SHALL ensure that the path exists, and that the process
    /// serving the request has `read` and `write` permissions to the path.
    /// This is a REQUIRED field.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string TargetPath {
      get { return targetPath_; }
      set {
        targetPath_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "volume_capability" field.</summary>
    public const int VolumeCapabilityFieldNumber = 5;
    private global::Csi.V0.VolumeCapability volumeCapability_;
    /// <summary>
    /// The capability of the volume the CO expects the volume to have.
    /// This is a REQUIRED field.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Csi.V0.VolumeCapability VolumeCapability {
      get { return volumeCapability_; }
      set {
        volumeCapability_ = value;
      }
    }

    /// <summary>Field number for the "readonly" field.</summary>
    public const int ReadonlyFieldNumber = 6;
    private bool readonly_;
    /// <summary>
    /// Whether to publish the volume in readonly mode. This field is
    /// REQUIRED.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Readonly {
      get { return readonly_; }
      set {
        readonly_ = value;
      }
    }

    /// <summary>Field number for the "node_publish_secrets" field.</summary>
    public const int NodePublishSecretsFieldNumber = 7;
    private static readonly pbc::MapField<string, string>.Codec _map_nodePublishSecrets_codec
        = new pbc::MapField<string, string>.Codec(pb::FieldCodec.ForString(10), pb::FieldCodec.ForString(18), 58);
    private readonly pbc::MapField<string, string> nodePublishSecrets_ = new pbc::MapField<string, string>();
    /// <summary>
    /// Secrets required by plugin to complete node publish volume request.
    /// A secret is a string to string map where the key identifies the
    /// name of the secret (e.g. "username" or "password"), and the value
    /// contains the secret data (e.g. "bob" or "abc123").
    /// Each key MUST consist of alphanumeric characters, '-', '_' or '.'.
    /// Each value MUST contain a valid string. An SP MAY choose to accept
    /// binary (non-string) data by using a binary-to-text encoding scheme,
    /// like base64.
    /// An SP SHALL advertise the requirements for required secret keys and
    /// values in documentation.
    /// CO SHALL permit passing through the required secrets.
    /// A CO MAY pass the same secrets to all RPCs, therefore the keys for
    /// all unique secrets that an SP expects must be unique across all CSI
    /// operations.
    /// This information is sensitive and MUST be treated as such (not
    /// logged, etc.) by the CO.
    /// This field is OPTIONAL.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::MapField<string, string> NodePublishSecrets {
      get { return nodePublishSecrets_; }
    }

    /// <summary>Field number for the "volume_attributes" field.</summary>
    public const int VolumeAttributesFieldNumber = 8;
    private static readonly pbc::MapField<string, string>.Codec _map_volumeAttributes_codec
        = new pbc::MapField<string, string>.Codec(pb::FieldCodec.ForString(10), pb::FieldCodec.ForString(18), 66);
    private readonly pbc::MapField<string, string> volumeAttributes_ = new pbc::MapField<string, string>();
    /// <summary>
    /// Attributes of the volume to publish. This field is OPTIONAL and
    /// MUST match the attributes of the Volume identified by
    /// `volume_id`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::MapField<string, string> VolumeAttributes {
      get { return volumeAttributes_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as NodePublishVolumeRequest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(NodePublishVolumeRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (VolumeId != other.VolumeId) return false;
      if (!PublishInfo.Equals(other.PublishInfo)) return false;
      if (StagingTargetPath != other.StagingTargetPath) return false;
      if (TargetPath != other.TargetPath) return false;
      if (!object.Equals(VolumeCapability, other.VolumeCapability)) return false;
      if (Readonly != other.Readonly) return false;
      if (!NodePublishSecrets.Equals(other.NodePublishSecrets)) return false;
      if (!VolumeAttributes.Equals(other.VolumeAttributes)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (VolumeId.Length != 0) hash ^= VolumeId.GetHashCode();
      hash ^= PublishInfo.GetHashCode();
      if (StagingTargetPath.Length != 0) hash ^= StagingTargetPath.GetHashCode();
      if (TargetPath.Length != 0) hash ^= TargetPath.GetHashCode();
      if (volumeCapability_ != null) hash ^= VolumeCapability.GetHashCode();
      if (Readonly != false) hash ^= Readonly.GetHashCode();
      hash ^= NodePublishSecrets.GetHashCode();
      hash ^= VolumeAttributes.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (VolumeId.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(VolumeId);
      }
      publishInfo_.WriteTo(output, _map_publishInfo_codec);
      if (StagingTargetPath.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(StagingTargetPath);
      }
      if (TargetPath.Length != 0) {
        output.WriteRawTag(34);
        output.WriteString(TargetPath);
      }
      if (volumeCapability_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(VolumeCapability);
      }
      if (Readonly != false) {
        output.WriteRawTag(48);
        output.WriteBool(Readonly);
      }
      nodePublishSecrets_.WriteTo(output, _map_nodePublishSecrets_codec);
      volumeAttributes_.WriteTo(output, _map_volumeAttributes_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (VolumeId.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(VolumeId);
      }
      size += publishInfo_.CalculateSize(_map_publishInfo_codec);
      if (StagingTargetPath.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(StagingTargetPath);
      }
      if (TargetPath.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(TargetPath);
      }
      if (volumeCapability_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(VolumeCapability);
      }
      if (Readonly != false) {
        size += 1 + 1;
      }
      size += nodePublishSecrets_.CalculateSize(_map_nodePublishSecrets_codec);
      size += volumeAttributes_.CalculateSize(_map_volumeAttributes_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(NodePublishVolumeRequest other) {
      if (other == null) {
        return;
      }
      if (other.VolumeId.Length != 0) {
        VolumeId = other.VolumeId;
      }
      publishInfo_.Add(other.publishInfo_);
      if (other.StagingTargetPath.Length != 0) {
        StagingTargetPath = other.StagingTargetPath;
      }
      if (other.TargetPath.Length != 0) {
        TargetPath = other.TargetPath;
      }
      if (other.volumeCapability_ != null) {
        if (volumeCapability_ == null) {
          volumeCapability_ = new global::Csi.V0.VolumeCapability();
        }
        VolumeCapability.MergeFrom(other.VolumeCapability);
      }
      if (other.Readonly != false) {
        Readonly = other.Readonly;
      }
      nodePublishSecrets_.Add(other.nodePublishSecrets_);
      volumeAttributes_.Add(other.volumeAttributes_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            VolumeId = input.ReadString();
            break;
          }
          case 18: {
            publishInfo_.AddEntriesFrom(input, _map_publishInfo_codec);
            break;
          }
          case 26: {
            StagingTargetPath = input.ReadString();
            break;
          }
          case 34: {
            TargetPath = input.ReadString();
            break;
          }
          case 42: {
            if (volumeCapability_ == null) {
              volumeCapability_ = new global::Csi.V0.VolumeCapability();
            }
            input.ReadMessage(volumeCapability_);
            break;
          }
          case 48: {
            Readonly = input.ReadBool();
            break;
          }
          case 58: {
            nodePublishSecrets_.AddEntriesFrom(input, _map_nodePublishSecrets_codec);
            break;
          }
          case 66: {
            volumeAttributes_.AddEntriesFrom(input, _map_volumeAttributes_codec);
            break;
          }
        }
      }
    }

  }

  public sealed partial class NodePublishVolumeResponse : pb::IMessage<NodePublishVolumeResponse> {
    private static readonly pb::MessageParser<NodePublishVolumeResponse> _parser = new pb::MessageParser<NodePublishVolumeResponse>(() => new NodePublishVolumeResponse());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<NodePublishVolumeResponse> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Csi.V0.CsiReflection.Descriptor.MessageTypes[32]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public NodePublishVolumeResponse() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public NodePublishVolumeResponse(NodePublishVolumeResponse other) : this() {
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public NodePublishVolumeResponse Clone() {
      return new NodePublishVolumeResponse(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as NodePublishVolumeResponse);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(NodePublishVolumeResponse other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(NodePublishVolumeResponse other) {
      if (other == null) {
        return;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
        }
      }
    }

  }

  public sealed partial class NodeUnpublishVolumeRequest : pb::IMessage<NodeUnpublishVolumeRequest> {
    private static readonly pb::MessageParser<NodeUnpublishVolumeRequest> _parser = new pb::MessageParser<NodeUnpublishVolumeRequest>(() => new NodeUnpublishVolumeRequest());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<NodeUnpublishVolumeRequest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Csi.V0.CsiReflection.Descriptor.MessageTypes[33]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public NodeUnpublishVolumeRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public NodeUnpublishVolumeRequest(NodeUnpublishVolumeRequest other) : this() {
      volumeId_ = other.volumeId_;
      targetPath_ = other.targetPath_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public NodeUnpublishVolumeRequest Clone() {
      return new NodeUnpublishVolumeRequest(this);
    }

    /// <summary>Field number for the "volume_id" field.</summary>
    public const int VolumeIdFieldNumber = 1;
    private string volumeId_ = "";
    /// <summary>
    /// The ID of the volume. This field is REQUIRED.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string VolumeId {
      get { return volumeId_; }
      set {
        volumeId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "target_path" field.</summary>
    public const int TargetPathFieldNumber = 2;
    private string targetPath_ = "";
    /// <summary>
    /// The path at which the volume was published. It MUST be an absolute
    /// path in the root filesystem of the process serving this request.
    /// This is a REQUIRED field.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string TargetPath {
      get { return targetPath_; }
      set {
        targetPath_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as NodeUnpublishVolumeRequest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(NodeUnpublishVolumeRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (VolumeId != other.VolumeId) return false;
      if (TargetPath != other.TargetPath) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (VolumeId.Length != 0) hash ^= VolumeId.GetHashCode();
      if (TargetPath.Length != 0) hash ^= TargetPath.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (VolumeId.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(VolumeId);
      }
      if (TargetPath.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(TargetPath);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (VolumeId.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(VolumeId);
      }
      if (TargetPath.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(TargetPath);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(NodeUnpublishVolumeRequest other) {
      if (other == null) {
        return;
      }
      if (other.VolumeId.Length != 0) {
        VolumeId = other.VolumeId;
      }
      if (other.TargetPath.Length != 0) {
        TargetPath = other.TargetPath;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            VolumeId = input.ReadString();
            break;
          }
          case 18: {
            TargetPath = input.ReadString();
            break;
          }
        }
      }
    }

  }

  public sealed partial class NodeUnpublishVolumeResponse : pb::IMessage<NodeUnpublishVolumeResponse> {
    private static readonly pb::MessageParser<NodeUnpublishVolumeResponse> _parser = new pb::MessageParser<NodeUnpublishVolumeResponse>(() => new NodeUnpublishVolumeResponse());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<NodeUnpublishVolumeResponse> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Csi.V0.CsiReflection.Descriptor.MessageTypes[34]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public NodeUnpublishVolumeResponse() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public NodeUnpublishVolumeResponse(NodeUnpublishVolumeResponse other) : this() {
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public NodeUnpublishVolumeResponse Clone() {
      return new NodeUnpublishVolumeResponse(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as NodeUnpublishVolumeResponse);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(NodeUnpublishVolumeResponse other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(NodeUnpublishVolumeResponse other) {
      if (other == null) {
        return;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
        }
      }
    }

  }

  public sealed partial class NodeGetIdRequest : pb::IMessage<NodeGetIdRequest> {
    private static readonly pb::MessageParser<NodeGetIdRequest> _parser = new pb::MessageParser<NodeGetIdRequest>(() => new NodeGetIdRequest());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<NodeGetIdRequest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Csi.V0.CsiReflection.Descriptor.MessageTypes[35]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public NodeGetIdRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public NodeGetIdRequest(NodeGetIdRequest other) : this() {
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public NodeGetIdRequest Clone() {
      return new NodeGetIdRequest(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as NodeGetIdRequest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(NodeGetIdRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(NodeGetIdRequest other) {
      if (other == null) {
        return;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
        }
      }
    }

  }

  public sealed partial class NodeGetIdResponse : pb::IMessage<NodeGetIdResponse> {
    private static readonly pb::MessageParser<NodeGetIdResponse> _parser = new pb::MessageParser<NodeGetIdResponse>(() => new NodeGetIdResponse());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<NodeGetIdResponse> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Csi.V0.CsiReflection.Descriptor.MessageTypes[36]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public NodeGetIdResponse() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public NodeGetIdResponse(NodeGetIdResponse other) : this() {
      nodeId_ = other.nodeId_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public NodeGetIdResponse Clone() {
      return new NodeGetIdResponse(this);
    }

    /// <summary>Field number for the "node_id" field.</summary>
    public const int NodeIdFieldNumber = 1;
    private string nodeId_ = "";
    /// <summary>
    /// The ID of the node as understood by the SP which SHALL be used by
    /// CO in subsequent `ControllerPublishVolume`.
    /// This is a REQUIRED field.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string NodeId {
      get { return nodeId_; }
      set {
        nodeId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as NodeGetIdResponse);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(NodeGetIdResponse other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (NodeId != other.NodeId) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (NodeId.Length != 0) hash ^= NodeId.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (NodeId.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(NodeId);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (NodeId.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(NodeId);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(NodeGetIdResponse other) {
      if (other == null) {
        return;
      }
      if (other.NodeId.Length != 0) {
        NodeId = other.NodeId;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            NodeId = input.ReadString();
            break;
          }
        }
      }
    }

  }

  public sealed partial class NodeGetCapabilitiesRequest : pb::IMessage<NodeGetCapabilitiesRequest> {
    private static readonly pb::MessageParser<NodeGetCapabilitiesRequest> _parser = new pb::MessageParser<NodeGetCapabilitiesRequest>(() => new NodeGetCapabilitiesRequest());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<NodeGetCapabilitiesRequest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Csi.V0.CsiReflection.Descriptor.MessageTypes[37]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public NodeGetCapabilitiesRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public NodeGetCapabilitiesRequest(NodeGetCapabilitiesRequest other) : this() {
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public NodeGetCapabilitiesRequest Clone() {
      return new NodeGetCapabilitiesRequest(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as NodeGetCapabilitiesRequest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(NodeGetCapabilitiesRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(NodeGetCapabilitiesRequest other) {
      if (other == null) {
        return;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
        }
      }
    }

  }

  public sealed partial class NodeGetCapabilitiesResponse : pb::IMessage<NodeGetCapabilitiesResponse> {
    private static readonly pb::MessageParser<NodeGetCapabilitiesResponse> _parser = new pb::MessageParser<NodeGetCapabilitiesResponse>(() => new NodeGetCapabilitiesResponse());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<NodeGetCapabilitiesResponse> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Csi.V0.CsiReflection.Descriptor.MessageTypes[38]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public NodeGetCapabilitiesResponse() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public NodeGetCapabilitiesResponse(NodeGetCapabilitiesResponse other) : this() {
      capabilities_ = other.capabilities_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public NodeGetCapabilitiesResponse Clone() {
      return new NodeGetCapabilitiesResponse(this);
    }

    /// <summary>Field number for the "capabilities" field.</summary>
    public const int CapabilitiesFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Csi.V0.NodeServiceCapability> _repeated_capabilities_codec
        = pb::FieldCodec.ForMessage(10, global::Csi.V0.NodeServiceCapability.Parser);
    private readonly pbc::RepeatedField<global::Csi.V0.NodeServiceCapability> capabilities_ = new pbc::RepeatedField<global::Csi.V0.NodeServiceCapability>();
    /// <summary>
    /// All the capabilities that the node service supports. This field
    /// is OPTIONAL.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Csi.V0.NodeServiceCapability> Capabilities {
      get { return capabilities_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as NodeGetCapabilitiesResponse);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(NodeGetCapabilitiesResponse other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!capabilities_.Equals(other.capabilities_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= capabilities_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      capabilities_.WriteTo(output, _repeated_capabilities_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += capabilities_.CalculateSize(_repeated_capabilities_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(NodeGetCapabilitiesResponse other) {
      if (other == null) {
        return;
      }
      capabilities_.Add(other.capabilities_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            capabilities_.AddEntriesFrom(input, _repeated_capabilities_codec);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Specifies a capability of the node service.
  /// </summary>
  public sealed partial class NodeServiceCapability : pb::IMessage<NodeServiceCapability> {
    private static readonly pb::MessageParser<NodeServiceCapability> _parser = new pb::MessageParser<NodeServiceCapability>(() => new NodeServiceCapability());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<NodeServiceCapability> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Csi.V0.CsiReflection.Descriptor.MessageTypes[39]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public NodeServiceCapability() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public NodeServiceCapability(NodeServiceCapability other) : this() {
      switch (other.TypeCase) {
        case TypeOneofCase.Rpc:
          Rpc = other.Rpc.Clone();
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public NodeServiceCapability Clone() {
      return new NodeServiceCapability(this);
    }

    /// <summary>Field number for the "rpc" field.</summary>
    public const int RpcFieldNumber = 1;
    /// <summary>
    /// RPC that the controller supports.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Csi.V0.NodeServiceCapability.Types.RPC Rpc {
      get { return typeCase_ == TypeOneofCase.Rpc ? (global::Csi.V0.NodeServiceCapability.Types.RPC) type_ : null; }
      set {
        type_ = value;
        typeCase_ = value == null ? TypeOneofCase.None : TypeOneofCase.Rpc;
      }
    }

    private object type_;
    /// <summary>Enum of possible cases for the "type" oneof.</summary>
    public enum TypeOneofCase {
      None = 0,
      Rpc = 1,
    }
    private TypeOneofCase typeCase_ = TypeOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TypeOneofCase TypeCase {
      get { return typeCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearType() {
      typeCase_ = TypeOneofCase.None;
      type_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as NodeServiceCapability);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(NodeServiceCapability other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Rpc, other.Rpc)) return false;
      if (TypeCase != other.TypeCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (typeCase_ == TypeOneofCase.Rpc) hash ^= Rpc.GetHashCode();
      hash ^= (int) typeCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (typeCase_ == TypeOneofCase.Rpc) {
        output.WriteRawTag(10);
        output.WriteMessage(Rpc);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (typeCase_ == TypeOneofCase.Rpc) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Rpc);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(NodeServiceCapability other) {
      if (other == null) {
        return;
      }
      switch (other.TypeCase) {
        case TypeOneofCase.Rpc:
          if (Rpc == null) {
            Rpc = new global::Csi.V0.NodeServiceCapability.Types.RPC();
          }
          Rpc.MergeFrom(other.Rpc);
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            global::Csi.V0.NodeServiceCapability.Types.RPC subBuilder = new global::Csi.V0.NodeServiceCapability.Types.RPC();
            if (typeCase_ == TypeOneofCase.Rpc) {
              subBuilder.MergeFrom(Rpc);
            }
            input.ReadMessage(subBuilder);
            Rpc = subBuilder;
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the NodeServiceCapability message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      public sealed partial class RPC : pb::IMessage<RPC> {
        private static readonly pb::MessageParser<RPC> _parser = new pb::MessageParser<RPC>(() => new RPC());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<RPC> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Csi.V0.NodeServiceCapability.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public RPC() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public RPC(RPC other) : this() {
          type_ = other.type_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public RPC Clone() {
          return new RPC(this);
        }

        /// <summary>Field number for the "type" field.</summary>
        public const int TypeFieldNumber = 1;
        private global::Csi.V0.NodeServiceCapability.Types.RPC.Types.Type type_ = 0;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Csi.V0.NodeServiceCapability.Types.RPC.Types.Type Type {
          get { return type_; }
          set {
            type_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as RPC);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(RPC other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Type != other.Type) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (Type != 0) hash ^= Type.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (Type != 0) {
            output.WriteRawTag(8);
            output.WriteEnum((int) Type);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (Type != 0) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Type);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(RPC other) {
          if (other == null) {
            return;
          }
          if (other.Type != 0) {
            Type = other.Type;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                type_ = (global::Csi.V0.NodeServiceCapability.Types.RPC.Types.Type) input.ReadEnum();
                break;
              }
            }
          }
        }

        #region Nested types
        /// <summary>Container for nested types declared in the RPC message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static partial class Types {
          public enum Type {
            [pbr::OriginalName("UNKNOWN")] Unknown = 0,
            [pbr::OriginalName("STAGE_UNSTAGE_VOLUME")] StageUnstageVolume = 1,
          }

        }
        #endregion

      }

    }
    #endregion

  }

  #endregion

}

#endregion Designer generated code
